//! `.env` merge and write utilities used by the init tool.
//!
//! The writer enforces the managed/unmanaged ownership model and keeps the
//! final file layout aligned with `.env.example`, while preserving user
//! overrides and custom lines across runs.

use std::{
    collections::{HashMap, HashSet},
    fs,
    io::Write,
    path::Path,
};

use anyhow::{Context, Result};
use tempfile::Builder;

/// Merge managed key/value pairs into an existing `.env` content, preserving
/// unknown/user-managed lines verbatim and appending managed entries in a
/// stable order.
pub fn merge_env_contents(
    existing: &str,
    managed: &[(String, String)],
    managed_keys: &HashSet<String>,
) -> String {
    let mut merged: Vec<String> = Vec::new();

    for line in existing.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() {
            merged.push(line.to_string());
            continue;
        }
        if trimmed.starts_with('#') {
            merged.push(line.to_string());
            continue;
        }

        let key = line.split_once('=').map(|(k, _)| k.trim()).unwrap_or(" ");

        if managed_keys.contains(key) {
            // Skip managed keys so we can re-append them with fresh values.
            continue;
        }

        merged.push(line.to_string());
    }

    for (key, value) in managed {
        merged.push(format!("{key}={value}"));
    }

    // Ensure file terminates with a newline for POSIX friendliness.
    let mut output = merged.join("\n");
    if !output.ends_with('\n') {
        output.push('\n');
    }
    output
}

/// Merge managed key/value pairs using `.env.example` as a layout template
/// when available.
///
/// Behavior:
/// - Section banners and comments from the template are preserved as-is.
/// - Managed keys present in the template are rendered using `managed` values.
/// - For non-managed keys present in the template, user overrides in
///   `existing` take precedence, otherwise the template value is used.
/// - Keys and comments that do not appear in the template are appended verbatim
///   in a `Custom overrides` section at the end.
pub fn merge_env_with_template(
    existing: &str,
    managed: &[(String, String)],
    managed_keys: &HashSet<String>,
    template: &str,
) -> String {
    // Build a map of managed key/value pairs for quick lookup.
    let mut managed_map: HashMap<String, String> = HashMap::new();
    for (key, value) in managed {
        managed_map.insert(key.clone(), value.clone());
    }

    // First pass over template: collect known keys and standard comments.
    let mut template_keys: HashSet<String> = HashSet::new();
    let mut template_comments: HashSet<String> = HashSet::new();

    for line in template.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() {
            continue;
        }
        if trimmed.starts_with('#') {
            template_comments.insert(line.to_string());
            continue;
        }
        if let Some((raw_key, _)) = line.split_once('=') {
            let key = raw_key.trim();
            if !key.is_empty() {
                template_keys.insert(key.to_string());
            }
        }
    }

    // Second pass over existing: capture user overrides for known keys and
    // collect custom keys/comments that do not exist in the template.
    let mut user_overrides: HashMap<String, String> = HashMap::new();
    let mut custom_lines: Vec<String> = Vec::new();
    let mut seen_custom = false;

    for line in existing.lines() {
        let trimmed = line.trim();

        if trimmed.is_empty() {
            if seen_custom {
                custom_lines.push(line.to_string());
            }
            continue;
        }

        if trimmed.starts_with('#') {
            // Skip comments that come from the template or from prior
            // ferrex-init runs; keep others as custom.
            if template_comments.contains(line)
                || trimmed
                    == "# Custom overrides (preserved from previous runs)"
                || trimmed
                    == "# Managed keys generated by ferrex-init (not present in template)"
            {
                continue;
            }
            custom_lines.push(line.to_string());
            seen_custom = true;
            continue;
        }

        let key = line.split_once('=').map(|(k, _)| k.trim()).unwrap_or("");
        if key.is_empty() {
            // Treat malformed lines as custom.
            custom_lines.push(line.to_string());
            seen_custom = true;
            continue;
        }

        if managed_keys.contains(key) {
            // Old managed values are discarded in favor of the fresh set.
            continue;
        }

        if template_keys.contains(key) {
            // User override for a known (non-managed) template key.
            user_overrides.insert(key.to_string(), line.to_string());
        } else {
            // Fully custom key; preserve in the custom section.
            custom_lines.push(line.to_string());
            seen_custom = true;
        }
    }

    // Third pass: render the final output using the template as the layout.
    let mut output: Vec<String> = Vec::new();
    let mut used_managed: HashSet<String> = HashSet::new();

    for line in template.lines() {
        let trimmed = line.trim();

        if trimmed.is_empty() {
            output.push(line.to_string());
            continue;
        }

        if trimmed.starts_with('#') {
            output.push(line.to_string());
            continue;
        }

        let (raw_key, _rest) = match line.split_once('=') {
            Some(pair) => pair,
            None => {
                // Not a standard KEY=VALUE line; preserve as-is.
                output.push(line.to_string());
                continue;
            }
        };

        let key = raw_key.trim();
        if key.is_empty() {
            output.push(line.to_string());
            continue;
        }

        if managed_keys.contains(key) {
            if let Some(value) = managed_map.get(key) {
                output.push(format!("{key}={value}"));
                used_managed.insert(key.to_string());
            } else {
                // Managed key in template without a computed value; keep the
                // template's line to avoid dropping it silently.
                output.push(line.to_string());
            }
        } else if let Some(override_line) = user_overrides.get(key) {
            // Known but user-managed key; honor the user's line.
            output.push(override_line.clone());
        } else {
            // Template default for a non-managed key.
            output.push(line.to_string());
        }
    }

    // Append any managed keys that are not present in the template.
    let mut extra_managed: Vec<String> = Vec::new();
    for (key, value) in managed {
        if managed_keys.contains(key) && !used_managed.contains(key) {
            extra_managed.push(format!("{key}={value}"));
        }
    }

    if !extra_managed.is_empty() {
        if !output.is_empty()
            && !output.last().map(|l| l.trim().is_empty()).unwrap_or(true)
        {
            output.push(String::new());
        }
        output.push(
            "# Managed keys generated by ferrex-init (not present in template)"
                .to_string(),
        );
        output.extend(extra_managed);
    }

    // Append custom overrides section if needed.
    if !custom_lines.is_empty() {
        if !output.is_empty()
            && !output.last().map(|l| l.trim().is_empty()).unwrap_or(true)
        {
            output.push(String::new());
        }
        output.push(
            "# Custom overrides (preserved from previous runs)".to_string(),
        );
        output.extend(custom_lines);
    }

    let mut result = output.join("\n");
    if !result.ends_with('\n') {
        result.push('\n');
    }
    result
}

/// Atomically write content to `path`, preserving the original permissions when
/// the file already exists.
pub fn write_env_atomically(path: &Path, contents: &str) -> Result<()> {
    let dir = path
        .parent()
        .map(|p| {
            if p.as_os_str().is_empty() {
                Path::new(".")
            } else {
                p
            }
        })
        .unwrap_or_else(|| Path::new("."));

    let mut builder = Builder::new();
    builder.prefix(".env.tmp");
    let mut tmp = builder
        .tempfile_in(dir)
        .context("failed to create temp file for env write")?;

    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent).with_context(|| {
            format!("failed to create parent directory {}", parent.display())
        })?;
    }

    tmp.as_file_mut()
        .write_all(contents.as_bytes())
        .context("failed to write env contents")?;

    // Preserve permissions when possible (POSIX only for now).
    if let Ok(metadata) = fs::metadata(path) {
        #[cfg(unix)]
        {
            let perms = metadata.permissions();
            tmp.as_file_mut()
                .set_permissions(perms)
                .context("failed to preserve .env permissions")?;
        }
    }

    tmp.persist(path)
        .context("failed to atomically persist env file")?;

    Ok(())
}

/// Load a `.env`-style file into a `HashMap`, treating a missing file as empty.
pub fn read_env_map(path: &Path) -> Result<HashMap<String, String>> {
    let mut map = HashMap::new();
    if !path.exists() {
        return Ok(map);
    }
    for entry in dotenvy::from_path_iter(path)? {
        let (k, v) = entry?;
        map.insert(k, v);
    }
    Ok(map)
}
