// Library management handlers
pub async fn list_libraries_handler(
    State(state): State<AppState>,
) -> Result<Json<Value>, StatusCode> {
    info!("Listing all libraries");

    match state.db.backend().list_libraries().await {
        Ok(libraries) => {
            info!("Found {} libraries", libraries.len());
            Ok(Json(json!({
                "status": "success",
                "libraries": libraries
            })))
        }
        Err(e) => {
            warn!("Failed to list libraries: {}", e);
            Ok(Json(json!({
                "status": "error",
                "error": e.to_string()
            })))
        }
    }
}

pub async fn get_library_handler(
    State(state): State<AppState>,
    Path(id): Path<String>,
) -> Result<Json<Value>, StatusCode> {
    info!("Getting library: {}", id);

    match state.db.backend().get_library(&id).await {
        Ok(Some(library)) => Ok(Json(json!({
            "status": "success",
            "library": library
        }))),
        Ok(None) => {
            warn!("Library not found: {}", id);
            Err(StatusCode::NOT_FOUND)
        }
        Err(e) => {
            warn!("Failed to get library: {}", e);
            Ok(Json(json!({
                "status": "error",
                "error": e.to_string()
            })))
        }
    }
}

pub async fn create_library_handler(
    State(state): State<AppState>,
    Json(request): Json<CreateLibraryRequest>,
) -> Result<Json<Value>, StatusCode> {
    info!("Creating library: {}", request.name);

    // Parse library type
    let library_type = match request.library_type.to_lowercase().as_str() {
        "movies" => LibraryType::Movies,
        "tvshows" | "tv_shows" | "tv" => LibraryType::TvShows,
        _ => {
            return Ok(Json(json!({
                "status": "error",
                "error": "Invalid library type. Use 'movies' or 'tvshows'"
            })));
        }
    };

    // Convert string paths to PathBuf
    let paths: Vec<std::path::PathBuf> = request
        .paths
        .into_iter()
        .map(std::path::PathBuf::from)
        .collect();

    // Validate paths exist
    for path in &paths {
        if !path.exists() {
            return Ok(Json(json!({
                "status": "error",
                "error": format!("Path does not exist: {}", path.display())
            })));
        }
    }

    let library = Library {
        id: uuid::Uuid::new_v4(),
        name: request.name,
        library_type,
        paths,
        scan_interval_minutes: request.scan_interval_minutes,
        last_scan: None,
        enabled: request.enabled,
        created_at: chrono::Utc::now(),
        updated_at: chrono::Utc::now(),
    };

    match state.db.backend().create_library(library).await {
        Ok(id) => {
            info!("Library created with ID: {}", id);
            Ok(Json(json!({
                "status": "success",
                "id": id,
                "message": "Library created successfully"
            })))
        }
        Err(e) => {
            warn!("Failed to create library: {}", e);
            Ok(Json(json!({
                "status": "error",
                "error": e.to_string()
            })))
        }
    }
}

pub async fn update_library_handler(
    State(state): State<AppState>,
    Path(id): Path<String>,
    Json(request): Json<UpdateLibraryRequest>,
) -> Result<Json<Value>, StatusCode> {
    info!("Updating library: {}", id);

    // Get existing library
    let mut library = match state.db.backend().get_library(&id).await {
        Ok(Some(lib)) => lib,
        Ok(None) => {
            warn!("Library not found: {}", id);
            return Err(StatusCode::NOT_FOUND);
        }
        Err(e) => {
            warn!("Failed to get library: {}", e);
            return Err(StatusCode::INTERNAL_SERVER_ERROR);
        }
    };

    // Update fields
    if let Some(name) = request.name {
        library.name = name;
    }

    if let Some(paths) = request.paths {
        let new_paths: Vec<std::path::PathBuf> =
            paths.into_iter().map(std::path::PathBuf::from).collect();

        // Validate paths exist
        for path in &new_paths {
            if !path.exists() {
                return Ok(Json(json!({
                    "status": "error",
                    "error": format!("Path does not exist: {}", path.display())
                })));
            }
        }

        library.paths = new_paths;
    }

    if let Some(interval) = request.scan_interval_minutes {
        library.scan_interval_minutes = interval;
    }

    if let Some(enabled) = request.enabled {
        library.enabled = enabled;
    }

    library.updated_at = chrono::Utc::now();

    match state.db.backend().update_library(&id, library).await {
        Ok(()) => {
            info!("Library updated: {}", id);
            Ok(Json(json!({
                "status": "success",
                "message": "Library updated successfully"
            })))
        }
        Err(e) => {
            warn!("Failed to update library: {}", e);
            Ok(Json(json!({
                "status": "error",
                "error": e.to_string()
            })))
        }
    }
}

pub async fn delete_library_handler(
    State(state): State<AppState>,
    Path(id): Path<String>,
) -> Result<Json<Value>, StatusCode> {
    info!("Deleting library: {}", id);

    match state.db.backend().delete_library(&id).await {
        Ok(()) => {
            info!("Library deleted: {}", id);
            Ok(Json(json!({
                "status": "success",
                "message": "Library deleted successfully"
            })))
        }
        Err(e) => {
            warn!("Failed to delete library: {}", e);
            Ok(Json(json!({
                "status": "error",
                "error": e.to_string()
            })))
        }
    }
}
pub async fn library_get_handler(
    State(state): State<AppState>,
    Query(filters): Query<LibraryFilters>,
) -> Result<Json<Value>, StatusCode> {
    info!("Library GET request with filters: {:?}", filters);
    library_handler_impl(state.db, filters).await
}

pub async fn library_post_handler(
    State(state): State<AppState>,
    Json(filters): Json<LibraryFilters>,
) -> Result<Json<Value>, StatusCode> {
    info!("Library POST request with filters: {:?}", filters);
    library_handler_impl(state.db, filters).await
}

pub async fn library_handler_impl(
    db: Arc<MediaDatabase>,
    filters: LibraryFilters,
) -> Result<Json<Value>, StatusCode> {
    info!("Library request with filters: {:?}", filters);

    let media_filters = MediaFilters {
        media_type: filters.media_type,
        show_name: filters.show_name,
        season: filters.season,
        order_by: filters.order_by,
        limit: filters.limit,
        library_id: filters
            .library_id
            .and_then(|id| uuid::Uuid::parse_str(&id).ok()),
    };

    match db.backend().list_media(media_filters).await {
        Ok(media_files) => {
            info!("Retrieved {} media files from library", media_files.len());
            Ok(Json(json!({
                "status": "success",
                "media_files": media_files,
                "count": media_files.len()
            })))
        }
        Err(e) => {
            warn!("Failed to retrieve library: {}", e);
            Ok(Json(json!({
                "status": "error",
                "error": e.to_string()
            })))
        }
    }
}
