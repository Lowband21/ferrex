# Shared, tracked pre-commit configuration for all worktrees.
#
# Works with both prek (recommended) and pre-commit:
#   prek: nix shell provides all dependencies; faster Rust-native hooks
#   pre-commit: falls back to remote repos with Python environments
#
# Setup:
#   prek install        # or: pre-commit install
#   prek run --all-files  # or: pre-commit run --all-files

minimum_pre_commit_version: "3.0.0"
default_stages: [pre-commit]

exclude: |
  ^(
    (?:.*/)?target/|
    (?:.*/)?\.sqlx/|
    (?:.*/)?cache/|
    (?:.*/)?dist-windows/
  )

repos:
  - repo: local
    hooks:
      - id: enforce-signed-commits-config
        name: ensure commit signing is enabled (config)
        language: system
        stages: [pre-commit]
        pass_filenames: false
        entry: bash
        args:
          - -c
          - |
            set -euo pipefail
            if [[ "$(git config --get commit.gpgSign || echo false)" != "true" ]]; then
              echo "ERROR: commit.gpgSign is not enabled. Enable with: git config --global commit.gpgSign true" >&2
              exit 1
            fi
            if ! git config --get user.signingkey >/dev/null; then
              echo "WARNING: user.signingkey is not set." >&2
            fi
            echo "Commit signing is enabled (gpg.format=$(git config --get gpg.format || echo openpgp))."

      - id: rustfmt-fix
        name: rustfmt (auto-fix staged .rs files)
        language: system
        pass_filenames: true
        files: \.rs$
        stages: [pre-commit]
        entry: bash
        args:
          - -c
          - |
            set -euo pipefail
            command -v rustfmt >/dev/null 2>&1 || { echo "rustfmt not found" >&2; exit 1; }
            edition=$(grep -E -m1 '^\s*edition\s*=\s*"(20[0-9]{2})"' Cargo.toml 2>/dev/null | sed -E 's/.*"(20[0-9]{2})".*/\1/' || echo "2024")
            files=()
            for f in "$@"; do [[ "$f" == *.rs ]] && files+=("$f"); done
            (( ${#files[@]} == 0 )) && exit 0
            rustfmt --edition "${edition}" --emit files "${files[@]}"
          - --

  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v5.0.0
    hooks:
      - id: trailing-whitespace
        args: ["--markdown-linebreak-ext=md"]
      - id: end-of-file-fixer
        exclude: \.rs$
      - id: mixed-line-ending
        args: ["--fix=lf"]
      - id: check-merge-conflict
      - id: check-yaml
      - id: check-toml
      - id: check-json
      - id: detect-private-key
      - id: check-case-conflict

  # Shell tools - use system binaries when available (nix shell provides these)
  - repo: local
    hooks:
      - id: shfmt
        name: shfmt (format shell scripts)
        language: system
        entry: shfmt -i 2 -ci -s -w
        files: \.(sh|bash)$
        types: [shell]
        stages: [pre-commit]

      - id: shellcheck
        name: shellcheck (lint shell scripts)
        language: system
        entry: shellcheck -x
        files: \.(sh|bash)$
        types: [shell]
        stages: [pre-commit]

      - id: hadolint
        name: hadolint (lint Dockerfiles)
        language: system
        entry: hadolint
        files: ^(.*/)?Dockerfile(\..*)?$
        stages: [pre-push]

  - repo: local
    hooks:
      - id: rustfmt
        name: rustfmt (check)
        entry: cargo fmt --all -- --check
        language: system
        pass_filenames: false
        stages: [pre-push]
        always_run: true

      - id: verify-signed-commits
        name: verify commit signatures (push range)
        language: system
        pass_filenames: false
        stages: [pre-push]
        always_run: true
        entry: bash
        args:
          - -c
          - |
            set -euo pipefail
            from_ref="${PRE_COMMIT_FROM_REF:-}"
            to_ref="${PRE_COMMIT_TO_REF:-}"
            if [[ -z "$from_ref" || -z "$to_ref" ]]; then
              if upstream=$(git rev-parse --abbrev-ref --symbolic-full-name @{upstream} 2>/dev/null); then
                base=$(git merge-base HEAD "$upstream") || true
                from_ref="${base:-}"
                to_ref="HEAD"
              else
                from_ref=""
                to_ref="HEAD"
              fi
            fi
            [[ -n "$from_ref" ]] && range="$from_ref..$to_ref" || range="$to_ref"
            mapfile -t commits < <(git rev-list --no-merges "$range" 2>/dev/null || true)
            (( ${#commits[@]} == 0 )) && exit 0
            unsigned=()
            for c in "${commits[@]}"; do
              sig=$(git log -1 --pretty=format:%G? "$c" 2>/dev/null) || sig="N"
              [[ "$sig" != "G" && "$sig" != "U" ]] && unsigned+=("$c:$sig")
            done
            if (( ${#unsigned[@]} > 0 )); then
              echo "ERROR: Found unsigned/invalid-signed commits:" >&2
              for u in "${unsigned[@]}"; do
                sha=${u%%:*}; code=${u##*:}
                subj=$(git log -1 --pretty=format:%s "$sha" 2>/dev/null || echo "")
                echo "  $sha [$code] $subj" >&2
              done
              echo "Enable signing: git config commit.gpgSign true" >&2
              exit 1
            fi

      - id: clippy
        name: cargo clippy (workspace, all targets, all features)
        entry: cargo clippy --workspace --all-targets --all-features -- -W warnings
        language: system
        pass_filenames: false
        stages: [pre-push]
        always_run: true

      - id: sqlx-prepare-check
        name: sqlx prepare --check (offline)
        language: system
        pass_filenames: false
        stages: [pre-push]
        always_run: true
        entry: bash
        args:
          - -c
          - SQLX_OFFLINE=true cargo sqlx prepare --workspace --check

      - id: cargo-deny
        name: cargo deny check
        entry: cargo deny check
        language: system
        pass_filenames: false
        stages: [pre-push]
        always_run: true
