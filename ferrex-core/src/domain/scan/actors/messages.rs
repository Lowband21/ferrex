use super::library::MaintenancePartition;
use crate::domain::scan::orchestration::context::FolderScanContext;
use crate::domain::scan::orchestration::{
    DedupeKey, JobId, JobPriority, LibraryRootsId, ScanReason,
};
use crate::{
    error::Result,
    player_prelude::{LibraryId, MediaID, VideoMediaType},
};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Classification hint for discovered media files during a folder scan.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum MediaKindHint {
    Movie,
    Episode,
    Extra,
    Unknown,
}

impl MediaKindHint {
    pub fn as_str(&self) -> &'static str {
        match self {
            MediaKindHint::Movie => "Movie",
            MediaKindHint::Episode => "Episode",
            MediaKindHint::Extra => "Extra",
            MediaKindHint::Unknown => "Unknown",
        }
    }
}

/// Event emitted by `FolderScanActor` when it finds a media file.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct MediaFileDiscovered {
    pub library_id: LibraryId,
    pub path_norm: String,
    pub fingerprint: crate::domain::scan::orchestration::job::MediaFingerprint,
    pub classified_as: MediaKindHint,
    pub media_id: MediaID,
    pub variant: VideoMediaType,
    pub node: ScanNodeKind,
    pub hierarchy: crate::domain::scan::AnalyzeScanHierarchy,
    pub context: FolderScanContext,
    pub scan_reason: ScanReason,
}

/// Request from a library actor to seed scans for a batch of folders.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SeedFoldersRequest {
    pub library_id: LibraryId,
    pub folders: Vec<SeededFolder>,
    pub mode: SeedMode,
    pub requested_at: DateTime<Utc>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum SeedMode {
    Startup,
    BulkInitialization,
    Maintenance,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SeededFolder {
    pub path_norm: String,
    pub priority: JobPriority,
    pub reason: ScanReason,
}

/// Maintenance scheduling plan generated by the library actor.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct MaintenanceBatch {
    pub library_id: LibraryId,
    pub partition: MaintenancePartition,
    pub folders: Vec<String>,
    pub issued_at: DateTime<Utc>,
}

/// Track idempotency tokens for folders that have already been enqueued.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct IssuedJobRecord {
    pub dedupe_key: DedupeKey,
    pub job_id: Option<JobId>,
    pub issued_at: DateTime<Utc>,
    pub pending_children: Vec<String>,
}

/// Response carrying a maintenance queue cursor per partition.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct MaintenanceSnapshot {
    pub partitions:
        HashMap<LibraryRootsId, (MaintenancePartition, DateTime<Utc>)>,
}

/// Hook for pluggable observers (metrics/tracing) to receive actor lifecycle events.
pub trait ActorObserver: Send + Sync {
    fn on_media_discovered(&self, _event: &MediaFileDiscovered) -> Result<()> {
        Ok(())
    }

    fn on_seed_batch(&self, _seed: &SeedFoldersRequest) -> Result<()> {
        Ok(())
    }

    fn on_maintenance_batch(&self, _batch: &MaintenanceBatch) -> Result<()> {
        Ok(())
    }
}

#[derive(Debug)]
pub struct NoopActorObserver;

impl ActorObserver for NoopActorObserver {}

/// Outcome summary produced by `FolderScanActor` for diagnostics.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct FolderScanSummary {
    pub context: FolderScanContext,
    pub discovered_files: usize,
    pub enqueued_subfolders: usize,
    pub listing_hash: String,
    pub completed_at: DateTime<Utc>,
}

use crate::domain::scan::orchestration::context::ScanNodeKind;
