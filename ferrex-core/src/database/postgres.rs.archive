use super::traits::*;
use crate::{MediaError, MediaFile, MediaFileMetadata, Result};
use crate::media::{
    MovieReference, SeriesReference, SeasonReference, EpisodeReference,
    LibraryReference, MovieID, SeriesID, SeasonID, EpisodeID,
    MovieTitle, SeriesTitle, SeasonNumber, EpisodeNumber,
    MovieURL, SeriesURL, SeasonURL, EpisodeURL,
    MediaDetailsOption,
};
use async_trait::async_trait;
use serde_json;
use sqlx::{postgres::PgPoolOptions, PgPool, Row, Connection};
use std::collections::HashMap;
use std::path::PathBuf;
use tracing::{debug, info, warn};
use uuid::Uuid;

#[derive(Debug, Clone)]
pub struct PostgresDatabase {
    pool: PgPool,
}

impl PostgresDatabase {
    fn row_to_media_file(&self, r: sqlx::postgres::PgRow) -> MediaFile {
        use sqlx::Row;

        let parsed_info = r
            .try_get::<Option<serde_json::Value>, _>("parsed_info")
            .unwrap_or(None)
            .and_then(|json| serde_json::from_value(json).ok());

        // Build external_info if we have external metadata
        let external_info = if r
            .try_get::<Option<String>, _>("external_id")
            .unwrap_or(None)
            .is_some()
        {
            Some(crate::ExternalMediaInfo {
                tmdb_id: r
                    .try_get::<Option<String>, _>("external_id")
                    .unwrap_or(None)
                    .and_then(|id| id.parse::<u32>().ok()),
                tvdb_id: None,
                imdb_id: None,
                description: r.try_get("overview").ok(),
                poster_url: r.try_get("poster_path").ok(),
                backdrop_url: r.try_get("backdrop_path").ok(),
                genres: r
                    .try_get::<Option<serde_json::Value>, _>("genres")
                    .unwrap_or(None)
                    .and_then(|g| serde_json::from_value::<Vec<String>>(g).ok())
                    .unwrap_or_default(),
                rating: r
                    .try_get::<Option<sqlx::types::BigDecimal>, _>("vote_average")
                    .unwrap_or(None)
                    .map(|v| v.to_string().parse::<f32>().unwrap_or(0.0)),
                release_date: r
                    .try_get::<Option<chrono::NaiveDate>, _>("release_date")
                    .unwrap_or(None),
                show_description: r.try_get("show_description").ok(),
                show_poster_url: r.try_get("show_poster_path").ok(),
                show_banner_url: r.try_get("show_banner_path").ok(),
                season_poster_url: r.try_get("season_poster_path").ok(),
                episode_still_url: r.try_get("episode_still_path").ok(),
            })
        } else {
            None
        };

        let duration = r
            .try_get::<Option<f64>, _>("duration_seconds")
            .unwrap_or(None);
        let width = r.try_get::<Option<i32>, _>("width").unwrap_or(None);

        let metadata = if duration.is_some()
            || width.is_some()
            || parsed_info.is_some()
            || external_info.is_some()
        {
            Some(MediaMetadata {
                duration,
                width: width.map(|w| w as u32),
                height: r
                    .try_get::<Option<i32>, _>("height")
                    .unwrap_or(None)
                    .map(|h| h as u32),
                video_codec: r.try_get("video_codec").ok(),
                audio_codec: r.try_get("audio_codec").ok(),
                bitrate: None,
                framerate: None,
                file_size: r.get::<i64, _>("file_size") as u64,
                // HDR metadata
                color_primaries: r.try_get("color_primaries").ok(),
                color_transfer: r.try_get("color_transfer").ok(),
                color_space: r.try_get("color_space").ok(),
                bit_depth: r.try_get::<Option<i32>, _>("bit_depth").unwrap_or(None).map(|b| b as u32),
                parsed_info,
                external_info,
            })
        } else {
            None
        };

        MediaFile {
            id: r.get("id"),
            path: std::path::PathBuf::from(r.get::<String, _>("file_path")),
            filename: r.get("file_name"),
            size: r.get::<i64, _>("file_size") as u64,
            created_at: r.get("created_at"),
            metadata,
            library_id: r.try_get("library_id").ok(),
            parent_media_id: r.try_get("parent_media_id").ok(),
        }
    }
    pub async fn new(connection_string: &str) -> Result<Self> {
        info!("Connecting to PostgreSQL database");

        // First, try to ensure the database exists
        if let Err(e) = Self::ensure_database_exists(connection_string).await {
            warn!("Could not ensure database exists: {}", e);
            // Continue anyway - maybe it already exists
        }

        let pool = PgPoolOptions::new()
            .max_connections(20)
            .connect(connection_string)
            .await
            .map_err(|e| {
                MediaError::InvalidMedia(format!("Failed to connect to PostgreSQL: {e}"))
            })?;

        info!("Successfully connected to PostgreSQL");

        Ok(Self { pool })
    }

    async fn ensure_database_exists(connection_string: &str) -> Result<()> {
        // Parse the connection string to extract database name
        let parts: Vec<&str> = connection_string.split('/').collect();
        if parts.len() < 2 {
            return Err(MediaError::InvalidMedia("Invalid connection string".to_string()));
        }

        let db_name = parts.last().unwrap().split('?').next().unwrap();
        let base_url = parts[..parts.len()-1].join("/");

        // Connect to postgres database to create our database
        let maintenance_url = format!("{}/postgres", base_url);

        debug!("Connecting to postgres database to ensure {} exists", db_name);

        match sqlx::postgres::PgConnection::connect(&maintenance_url).await {
            Ok(mut conn) => {
                // Check if database exists
                let exists: bool = sqlx::query_scalar(&format!(
                    "SELECT EXISTS(SELECT 1 FROM pg_database WHERE datname = '{}')",
                    db_name
                ))
                .fetch_one(&mut conn)
                .await
                .unwrap_or(false);

                if !exists {
                    info!("Creating database: {}", db_name);
                    sqlx::query(&format!("CREATE DATABASE \"{}\"", db_name))
                        .execute(&mut conn)
                        .await
                        .map_err(|e| MediaError::InvalidMedia(format!("Failed to create database: {e}")))?;
                    info!("Database {} created successfully", db_name);
                } else {
                    debug!("Database {} already exists", db_name);
                }
                Ok(())
            }
            Err(e) => {
                warn!("Could not connect to postgres database: {}", e);
                Err(MediaError::InvalidMedia(format!("Failed to connect to postgres database: {e}")))
            }
        }
    }

    async fn run_migrations(pool: &sqlx::PgPool) -> Result<()> {
        info!("Running database migrations");

        // Simple approach: just create tables if they don't exist
        // PostgreSQL's CREATE TABLE IF NOT EXISTS handles this gracefully

        // Create libraries table
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS libraries (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                name TEXT NOT NULL,
                library_type TEXT NOT NULL,
                paths TEXT[] NOT NULL,
                scan_interval_minutes INTEGER NOT NULL DEFAULT 60,
                last_scan TIMESTAMPTZ,
                enabled BOOLEAN NOT NULL DEFAULT true,
                created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
            )
            "#,
        )
        .execute(pool)
        .await
        .map_err(|e| {
            MediaError::InvalidMedia(format!("Failed to create libraries table: {e}"))
        })?;

        // Create media_files table
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS media_files (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                file_path TEXT NOT NULL UNIQUE,
                file_name TEXT NOT NULL,
                file_size BIGINT NOT NULL,
                media_type TEXT NOT NULL DEFAULT 'unknown',
                parent_directory TEXT NOT NULL,
                library_id UUID REFERENCES libraries(id) ON DELETE CASCADE,
                parent_media_id UUID REFERENCES media_files(id) ON DELETE CASCADE,
                created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                last_scanned_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
            )
            "#,
        )
        .execute(pool)
        .await
        .map_err(|e| {
            MediaError::InvalidMedia(format!("Failed to create media_files table: {e}"))
        })?;

        // Add library_id column if it doesn't exist (for migration from older schema)
        sqlx::query(
            r#"
            DO $$
            BEGIN
                IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                              WHERE table_name='media_files' AND column_name='library_id') THEN
                    ALTER TABLE media_files ADD COLUMN library_id UUID REFERENCES libraries(id) ON DELETE CASCADE;
                END IF;
            END $$
            "#,
        )
        .execute(pool)
        .await
        .map_err(|e| {
            MediaError::InvalidMedia(format!("Failed to add library_id column: {e}"))
        })?;

        // Add parent_media_id column if it doesn't exist (for extras support)
        sqlx::query(
            r#"
            DO $$
            BEGIN
                IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                              WHERE table_name='media_files' AND column_name='parent_media_id') THEN
                    ALTER TABLE media_files ADD COLUMN parent_media_id UUID REFERENCES media_files(id) ON DELETE CASCADE;
                END IF;
            END $$
            "#,
        )
        .execute(pool)
        .await
        .map_err(|e| {
            MediaError::InvalidMedia(format!("Failed to add parent_media_id column: {e}"))
        })?;

        // Create indexes
        sqlx::query("CREATE INDEX IF NOT EXISTS idx_media_files_path ON media_files(file_path)")
            .execute(pool)
            .await
            .map_err(|e| MediaError::InvalidMedia(format!("Failed to create index: {e}")))?;
        sqlx::query("CREATE INDEX IF NOT EXISTS idx_media_files_parent_dir ON media_files(parent_directory)")
            .execute(pool).await
            .map_err(|e| MediaError::InvalidMedia(format!("Failed to create index: {e}")))?;
        sqlx::query("CREATE INDEX IF NOT EXISTS idx_media_files_library ON media_files(library_id)")
            .execute(pool).await
            .map_err(|e| MediaError::InvalidMedia(format!("Failed to create index: {e}")))?;

        // Create media_metadata table
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS media_metadata (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                media_file_id UUID NOT NULL REFERENCES media_files(id) ON DELETE CASCADE,
                duration_seconds DOUBLE PRECISION,
                width INTEGER,
                height INTEGER,
                video_codec TEXT,
                audio_codec TEXT,
                bitrate BIGINT,
                frame_rate DOUBLE PRECISION,
                parsed_info JSONB,
                bit_depth INTEGER,
                color_transfer TEXT,
                color_space TEXT,
                color_primaries TEXT,
                created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                UNIQUE(media_file_id)
            )
            "#,
        )
        .execute(pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to create table: {e}")))?;

        // Create external_metadata table
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS external_metadata (
                id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                media_file_id UUID NOT NULL REFERENCES media_files(id) ON DELETE CASCADE,
                source TEXT NOT NULL DEFAULT 'tmdb',
                external_id TEXT,
                title TEXT,
                overview TEXT,
                release_date DATE,
                vote_average DECIMAL(3, 1),
                poster_path TEXT,
                backdrop_path TEXT,
                genres JSONB,
                show_description TEXT,
                show_poster_path TEXT,
                season_poster_path TEXT,
                episode_still_path TEXT,
                created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
                UNIQUE(media_file_id, source)
            )
            "#,
        )
        .execute(pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to create table: {e}")))?;

        // Add source column and update constraint for existing installations
        sqlx::query(
            r#"
            DO $$
            BEGIN
                -- Add source column if it doesn't exist
                IF NOT EXISTS (SELECT 1 FROM information_schema.columns
                              WHERE table_name='external_metadata' AND column_name='source') THEN
                    ALTER TABLE external_metadata ADD COLUMN source TEXT NOT NULL DEFAULT 'tmdb';
                END IF;

                -- Drop old unique constraint if it exists
                IF EXISTS (SELECT 1 FROM pg_constraint
                          WHERE conname = 'external_metadata_media_file_id_key') THEN
                    ALTER TABLE external_metadata DROP CONSTRAINT external_metadata_media_file_id_key;
                END IF;

                -- Add new composite unique constraint if it doesn't exist
                IF NOT EXISTS (SELECT 1 FROM pg_constraint
                              WHERE conname = 'external_metadata_media_file_id_source_key') THEN
                    ALTER TABLE external_metadata ADD CONSTRAINT external_metadata_media_file_id_source_key
                        UNIQUE(media_file_id, source);
                END IF;
            END $$
            "#,
        )
        .execute(pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to update external_metadata constraints: {e}")))?;

        // Add HDR metadata columns if they don't exist (for existing installations)
        sqlx::query(
            r#"
            ALTER TABLE media_metadata
            ADD COLUMN IF NOT EXISTS bit_depth INTEGER,
            ADD COLUMN IF NOT EXISTS color_transfer TEXT,
            ADD COLUMN IF NOT EXISTS color_space TEXT,
            ADD COLUMN IF NOT EXISTS color_primaries TEXT
            "#,
        )
        .execute(pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to add HDR columns: {e}")))?;

        info!("Database migrations completed successfully");
        Ok(())
    }
}

#[async_trait]
impl MediaDatabaseTrait for PostgresDatabase {
    async fn initialize_schema(&self) -> Result<()> {
        Self::run_migrations(&self.pool).await
    }

    async fn store_media(&self, media_file: MediaFile) -> Result<String> {
        debug!("Storing media file: {}", media_file.filename);

        let media_type = media_file
            .metadata
            .as_ref()
            .and_then(|m| m.parsed_info.as_ref())
            .map(|p| match p.media_type {
                crate::MediaType::Movie => "movie",
                crate::MediaType::TvEpisode => "tv_show",
                crate::MediaType::Extra => "extra",
                crate::MediaType::Unknown => "unknown",
            })
            .unwrap_or("unknown")
            .to_string();

        let parent_dir = media_file
            .path
            .parent()
            .map(|p| p.to_string_lossy().to_string())
            .unwrap_or_else(|| "/".to_string());

        let id: (Uuid,) = sqlx::query_as(
            r#"
            INSERT INTO media_files (id, file_path, file_name, file_size, media_type, parent_directory, library_id, parent_media_id)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
            ON CONFLICT (file_path) DO UPDATE
            SET file_name = EXCLUDED.file_name,
                file_size = EXCLUDED.file_size,
                library_id = EXCLUDED.library_id,
                parent_media_id = EXCLUDED.parent_media_id,
                updated_at = NOW()
            RETURNING id
            "#
        )
        .bind(media_file.id)
        .bind(media_file.path.to_string_lossy().to_string())
        .bind(&media_file.filename)
        .bind(media_file.size as i64)
        .bind(media_type)
        .bind(parent_dir)
        .bind(media_file.library_id)
        .bind(media_file.parent_media_id)
        .fetch_one(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to store media: {e}")))?;

        if let Some(metadata) = &media_file.metadata {
            let parsed_info_json = metadata
                .parsed_info
                .as_ref()
                .and_then(|pi| serde_json::to_value(pi).ok());

            sqlx::query!(
                r#"
                INSERT INTO media_metadata (
                    media_file_id, duration_seconds, width, height,
                    video_codec, audio_codec, bitrate_bps, framerate, parsed_info,
                    bit_depth, color_transfer, color_space, color_primaries
                )
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
                ON CONFLICT (media_file_id) DO UPDATE
                SET duration_seconds = EXCLUDED.duration_seconds,
                    width = EXCLUDED.width,
                    height = EXCLUDED.height,
                    parsed_info = EXCLUDED.parsed_info,
                    bit_depth = EXCLUDED.bit_depth,
                    color_transfer = EXCLUDED.color_transfer,
                    color_space = EXCLUDED.color_space,
                    color_primaries = EXCLUDED.color_primaries,
                    updated_at = NOW()
                "#,
                id.0,
                metadata.duration,
                metadata.width.map(|w| w as i32),
                metadata.height.map(|h| h as i32),
                metadata.video_codec.as_deref(),
                metadata.audio_codec.as_deref(),
                metadata.bitrate.map(|b| b as i64),
                metadata.framerate,
                parsed_info_json,
                metadata.bit_depth.map(|b| b as i32),
                metadata.color_transfer.as_deref(),
                metadata.color_space.as_deref(),
                metadata.color_primaries.as_deref()
            )
            .execute(&self.pool)
            .await
            .map_err(|e| {
                MediaError::InvalidMedia(format!("Failed to store technical metadata: {e}"))
            })?;

            // Store external metadata if available
            if metadata.external_info.is_some() {
                if let Err(e) = self
                    .store_external_metadata(&id.0.to_string(), metadata)
                    .await
                {
                    warn!("Failed to store external metadata: {}", e);
                }
            }
        }

        Ok(id.0.to_string())
    }

    async fn store_media_batch(&self, media_files: Vec<MediaFile>) -> Result<Vec<String>> {
        if media_files.is_empty() {
            return Ok(Vec::new());
        }

        debug!("Storing batch of {} media files", media_files.len());

        // Start a transaction for batch operation
        let mut tx = self.pool.begin().await
            .map_err(|e| MediaError::InvalidMedia(format!("Failed to start transaction: {e}")))?;

        let mut stored_ids = Vec::new();
        let mut tv_shows_to_create = std::collections::HashMap::new();

        // Process files in the batch
        for media_file in media_files {
            let media_type = media_file
                .metadata
                .as_ref()
                .and_then(|m| m.parsed_info.as_ref())
                .map(|p| match p.media_type {
                    crate::MediaType::Movie => "movie",
                    crate::MediaType::TvEpisode => "tv_show",
                    crate::MediaType::Extra => "extra",
                    crate::MediaType::Unknown => "unknown",
                })
                .unwrap_or("unknown")
                .to_string();

            let parent_dir = media_file
                .path
                .parent()
                .map(|p| p.to_string_lossy().to_string())
                .unwrap_or_else(|| "/".to_string());

            // Insert media file
            let id: (Uuid,) = sqlx::query_as(
                r#"
                INSERT INTO media_files (id, file_path, file_name, file_size, media_type, parent_directory, library_id, parent_media_id)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
                ON CONFLICT (file_path) DO UPDATE
                SET file_name = EXCLUDED.file_name,
                    file_size = EXCLUDED.file_size,
                    library_id = EXCLUDED.library_id,
                    parent_media_id = EXCLUDED.parent_media_id,
                    updated_at = NOW()
                RETURNING id
                "#
            )
            .bind(media_file.id)
            .bind(media_file.path.to_string_lossy().to_string())
            .bind(&media_file.filename)
            .bind(media_file.size as i64)
            .bind(&media_type)
            .bind(&parent_dir)
            .bind(media_file.library_id)
            .bind(media_file.parent_media_id)
            .fetch_one(&mut *tx)
            .await
            .map_err(|e| MediaError::InvalidMedia(format!("Failed to store media in batch: {e}")))?;

            // Insert metadata if available
            if let Some(metadata) = &media_file.metadata {
                let parsed_info_json = metadata
                    .parsed_info
                    .as_ref()
                    .and_then(|pi| serde_json::to_value(pi).ok());

                sqlx::query!(
                    r#"
                    INSERT INTO media_metadata (
                        media_file_id, duration_seconds, width, height,
                        video_codec, audio_codec, bitrate_bps, framerate, parsed_info,
                        bit_depth, color_transfer, color_space, color_primaries
                    )
                    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
                    ON CONFLICT (media_file_id) DO UPDATE
                    SET duration_seconds = EXCLUDED.duration_seconds,
                        width = EXCLUDED.width,
                        height = EXCLUDED.height,
                        parsed_info = EXCLUDED.parsed_info,
                        bit_depth = EXCLUDED.bit_depth,
                        color_transfer = EXCLUDED.color_transfer,
                        color_space = EXCLUDED.color_space,
                        color_primaries = EXCLUDED.color_primaries,
                        updated_at = NOW()
                    "#,
                    id.0,
                    metadata.duration,
                    metadata.width.map(|w| w as i32),
                    metadata.height.map(|h| h as i32),
                    metadata.video_codec.as_deref(),
                    metadata.audio_codec.as_deref(),
                    metadata.bitrate.map(|b| b as i64),
                    metadata.framerate,
                    parsed_info_json,
                    metadata.bit_depth.map(|b| b as i32),
                    metadata.color_transfer.as_deref(),
                    metadata.color_space.as_deref(),
                    metadata.color_primaries.as_deref()
                )
                .execute(&mut *tx)
                .await
                .map_err(|e| {
                    MediaError::InvalidMedia(format!("Failed to store technical metadata in batch: {e}"))
                })?;

                // Store external metadata if available
                if let Some(external) = &metadata.external_info {
                    let title = external
                        .description
                        .as_ref()
                        .map(|d| d.chars().take(100).collect::<String>())
                        .unwrap_or_else(|| "Unknown".to_string());

                    let genres_json = if !external.genres.is_empty() {
                        Some(serde_json::to_value(&external.genres).unwrap_or(serde_json::Value::Null))
                    } else {
                        None
                    };

                    sqlx::query!(
                        r#"
                        INSERT INTO external_metadata (
                            media_file_id, source, external_id, title, overview, release_date,
                            vote_average, poster_path, backdrop_path, genres,
                            show_description, show_poster_path, season_poster_path, episode_still_path
                        )
                        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
                        ON CONFLICT (media_file_id, source) DO UPDATE
                        SET external_id = EXCLUDED.external_id,
                            title = EXCLUDED.title,
                            overview = EXCLUDED.overview,
                            poster_path = EXCLUDED.poster_path,
                            backdrop_path = EXCLUDED.backdrop_path,
                            genres = EXCLUDED.genres,
                            vote_average = EXCLUDED.vote_average,
                            show_description = EXCLUDED.show_description,
                            show_poster_path = EXCLUDED.show_poster_path,
                            season_poster_path = EXCLUDED.season_poster_path,
                            episode_still_path = EXCLUDED.episode_still_path,
                            updated_at = NOW()
                        "#,
                        id.0,
                        "tmdb",
                        external
                            .tmdb_id
                            .map(|id| id.to_string())
                            .unwrap_or_else(|| "unknown".to_string()),
                        title,
                        external.description.as_deref(),
                        external.release_date,
                        external.rating.map(|r| {
                            use sqlx::types::BigDecimal;
                            use std::str::FromStr;
                            BigDecimal::from_str(&r.to_string()).unwrap_or_default()
                        }),
                        external.poster_url.as_deref(),
                        external.backdrop_url.as_deref(),
                        genres_json,
                        external.show_description.as_deref(),
                        external.show_poster_url.as_deref(),
                        external.season_poster_url.as_deref(),
                        external.episode_still_url.as_deref()
                    )
                    .execute(&mut *tx)
                    .await
                    .map_err(|e| {
                        MediaError::InvalidMedia(format!("Failed to store external metadata in batch: {e}"))
                    })?;

                    // Collect TV shows to create (deduplication)
                    if let Some(parsed) = &metadata.parsed_info {
                        if parsed.media_type == crate::MediaType::TvEpisode {
                            if let (Some(show_name), Some(tmdb_id)) = (&parsed.show_name, external.tmdb_id) {
                                tv_shows_to_create.entry(tmdb_id).or_insert_with(|| {
                                    (show_name.clone(), external.clone())
                                });
                            }
                        }
                    }
                }
            }

            stored_ids.push(id.0.to_string());
        }

        // Create TV shows in batch (deduplicated)
        for (tmdb_id, (show_name, external)) in tv_shows_to_create {
            // Check if show already exists
            let exists = sqlx::query!(
                "SELECT EXISTS(SELECT 1 FROM tv_shows WHERE tmdb_id = $1) as exists",
                tmdb_id as i32
            )
            .fetch_one(&mut *tx)
            .await
            .map_err(|e| MediaError::InvalidMedia(format!("Failed to check TV show existence: {e}")))?
            .exists
            .unwrap_or(false);

            if !exists {
                sqlx::query!(
                    r#"
                    INSERT INTO tv_shows (id, tmdb_id, name, overview, poster_path, backdrop_path)
                    VALUES ($1, $2, $3, $4, $5, $6)
                    ON CONFLICT (tmdb_id) DO NOTHING
                    "#,
                    Uuid::new_v4(),
                    tmdb_id as i32,
                    show_name,
                    external.show_description.as_deref().or(external.description.as_deref()),
                    external.show_poster_url.as_deref().or(external.poster_url.as_deref()),
                    external.backdrop_url.as_deref()
                )
                .execute(&mut *tx)
                .await
                .map_err(|e| MediaError::InvalidMedia(format!("Failed to create TV show in batch: {e}")))?;
            }
        }

        // Commit transaction
        tx.commit().await
            .map_err(|e| MediaError::InvalidMedia(format!("Failed to commit batch transaction: {e}")))?;

        debug!("Successfully stored batch of {} media files", stored_ids.len());
        Ok(stored_ids)
    }

    async fn get_media_by_path(&self, path: &str) -> Result<Option<MediaFile>> {
        debug!("Retrieving media file by path: {}", path);

        let row = sqlx::query(
            r#"
            SELECT
                mf.id, mf.file_path, mf.file_name, mf.file_size, mf.created_at, mf.library_id, mf.parent_media_id,
                mm.duration_seconds, mm.width, mm.height, mm.video_codec, mm.audio_codec,
                mm.parsed_info, mm.bit_depth, mm.color_transfer, mm.color_space, mm.color_primaries,
                em.external_id, em.title, em.overview, em.release_date,
                em.vote_average, em.poster_path, em.backdrop_path, em.genres,
                em.show_description, em.show_poster_path, em.season_poster_path, em.episode_still_path
            FROM media_files mf
            LEFT JOIN media_metadata mm ON mf.id = mm.media_file_id
            LEFT JOIN external_metadata em ON mf.id = em.media_file_id
            WHERE mf.file_path = $1
            "#
        )
        .bind(path)
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to retrieve media by path: {e}")))?;

        match row {
            Some(row) => Ok(Some(self.row_to_media_file(row))),
            None => Ok(None),
        }
    }

    async fn get_media(&self, id: &str) -> Result<Option<MediaFile>> {
        debug!("Retrieving media file: {}", id);

        // Strip "media:" prefix if present (for compatibility with SurrealDB format)
        let uuid_str = if id.starts_with("media:") {
            id.strip_prefix("media:").unwrap_or(id)
        } else {
            id
        };

        let uuid = Uuid::parse_str(uuid_str)
            .map_err(|e| MediaError::InvalidMedia(format!("Invalid UUID: {e}")))?;

        let row = sqlx::query(
            r#"
            SELECT
                mf.id, mf.file_path, mf.file_name, mf.file_size, mf.created_at, mf.library_id, mf.parent_media_id,
                mm.duration_seconds, mm.width, mm.height, mm.video_codec, mm.audio_codec,
                mm.parsed_info, mm.bit_depth, mm.color_transfer, mm.color_space, mm.color_primaries,
                em.external_id, em.title, em.overview, em.release_date,
                em.vote_average, em.poster_path, em.backdrop_path, em.genres,
                em.show_description, em.show_poster_path, em.season_poster_path, em.episode_still_path
            FROM media_files mf
            LEFT JOIN media_metadata mm ON mf.id = mm.media_file_id
            LEFT JOIN external_metadata em ON mf.id = em.media_file_id
            WHERE mf.id = $1
            "#
        )
        .bind(uuid)
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to retrieve media: {e}")))?;

        Ok(row.map(|r| self.row_to_media_file(r)))
    }

    async fn list_media(&self, filters: MediaFilters) -> Result<Vec<MediaFile>> {
        debug!("Listing media files with filters: {:?}", filters);

        let mut query = String::from(
            r#"
            SELECT
                mf.id, mf.file_path, mf.file_name, mf.file_size, mf.created_at, mf.media_type, mf.library_id, mf.parent_media_id,
                mm.duration_seconds, mm.width, mm.height, mm.video_codec, mm.audio_codec,
                mm.parsed_info, mm.bit_depth, mm.color_transfer, mm.color_space, mm.color_primaries,
                em.external_id, em.title, em.overview, em.release_date,
                em.vote_average, em.poster_path, em.backdrop_path, em.genres,
                em.show_description, em.show_poster_path, em.season_poster_path, em.episode_still_path
            FROM media_files mf
            LEFT JOIN media_metadata mm ON mf.id = mm.media_file_id
            LEFT JOIN external_metadata em ON mf.id = em.media_file_id
            WHERE 1=1
            "#,
        );

        let mut param_count = 0;

        if filters.media_type.is_some() {
            param_count += 1;
            query.push_str(&format!(" AND mf.media_type = ${param_count}"));
        }

        if filters.show_name.is_some() {
            param_count += 1;
            query.push_str(&format!(
                " AND mm.parsed_info->>'show_name' = ${param_count}"
            ));
        }

        if filters.season.is_some() {
            param_count += 1;
            query.push_str(&format!(
                " AND (mm.parsed_info->>'season')::int = ${param_count}"
            ));
        }

        if filters.library_id.is_some() {
            param_count += 1;
            query.push_str(&format!(" AND mf.library_id = ${param_count}"));
        }

        match filters.order_by.as_deref() {
            Some("name") => query.push_str(" ORDER BY mf.file_name ASC"),
            Some("date") => query.push_str(" ORDER BY mf.created_at DESC"),
            Some("size") => query.push_str(" ORDER BY mf.file_size DESC"),
            _ => query.push_str(" ORDER BY mf.created_at DESC"),
        }

        if let Some(limit) = filters.limit {
            query.push_str(&format!(" LIMIT {limit}"));
        }

        let mut query_builder = sqlx::query(&query);

        if let Some(media_type) = &filters.media_type {
            query_builder = query_builder.bind(media_type);
        }

        if let Some(show_name) = &filters.show_name {
            query_builder = query_builder.bind(show_name);
        }

        if let Some(season) = &filters.season {
            query_builder = query_builder.bind(*season as i32);
        }

        if let Some(library_id) = &filters.library_id {
            query_builder = query_builder.bind(library_id);
        }

        let rows = query_builder
            .fetch_all(&self.pool)
            .await
            .map_err(|e| MediaError::InvalidMedia(format!("Failed to list media: {e}")))?;

        let mut media_files = Vec::new();
        for row in rows {
            // Try to get parsed_info regardless of whether other metadata exists
            let parsed_info = row
                .try_get::<Option<serde_json::Value>, _>("parsed_info")
                .unwrap_or(None)
                .and_then(|json| serde_json::from_value(json).ok());

            // Build external_info if we have external metadata
            let external_info = if row
                .try_get::<Option<String>, _>("external_id")
                .unwrap_or(None)
                .is_some()
            {
                Some(crate::ExternalMediaInfo {
                    tmdb_id: row
                        .try_get::<Option<String>, _>("external_id")
                        .unwrap_or(None)
                        .and_then(|id| id.parse::<u32>().ok()),
                    tvdb_id: None,
                    imdb_id: None,
                    description: row.try_get("overview").ok(),
                    poster_url: row.try_get("poster_path").ok(),
                    backdrop_url: row.try_get("backdrop_path").ok(),
                    genres: row
                        .try_get::<Option<serde_json::Value>, _>("genres")
                        .unwrap_or(None)
                        .and_then(|g| serde_json::from_value::<Vec<String>>(g).ok())
                        .unwrap_or_default(),
                    rating: row
                        .try_get::<Option<sqlx::types::BigDecimal>, _>("vote_average")
                        .unwrap_or(None)
                        .map(|v| v.to_string().parse::<f32>().unwrap_or(0.0)),
                    release_date: row
                        .try_get::<Option<chrono::NaiveDate>, _>("release_date")
                        .unwrap_or(None),
                    show_description: row.try_get("show_description").ok(),
                    show_poster_url: row.try_get("show_poster_path").ok(),
                    show_banner_url: row.try_get("show_banner_path").ok(),
                    season_poster_url: row.try_get("season_poster_path").ok(),
                    episode_still_url: row.try_get("episode_still_path").ok(),
                })
            } else {
                None
            };

            let duration = row
                .try_get::<Option<f64>, _>("duration_seconds")
                .unwrap_or(None);
            let width = row.try_get::<Option<i32>, _>("width").unwrap_or(None);

            let metadata = if duration.is_some()
                || width.is_some()
                || parsed_info.is_some()
                || external_info.is_some()
            {
                Some(MediaMetadata {
                    duration,
                    width: width.map(|w| w as u32),
                    height: row
                        .try_get::<Option<i32>, _>("height")
                        .unwrap_or(None)
                        .map(|h| h as u32),
                    video_codec: row.try_get("video_codec").ok(),
                    audio_codec: row.try_get("audio_codec").ok(),
                    bitrate: None,
                    framerate: None,
                    file_size: row.get::<i64, _>("file_size") as u64,
                    // HDR metadata
                    color_primaries: row.try_get("color_primaries").ok(),
                    color_transfer: row.try_get("color_transfer").ok(),
                    color_space: row.try_get("color_space").ok(),
                    bit_depth: row.try_get::<Option<i32>, _>("bit_depth").unwrap_or(None).map(|b| b as u32),
                    parsed_info,
                    external_info,
                })
            } else {
                None
            };

            media_files.push(MediaFile {
                id: row.get("id"),
                path: std::path::PathBuf::from(row.get::<String, _>("file_path")),
                filename: row.get("file_name"),
                size: row.get::<i64, _>("file_size") as u64,
                created_at: row.get("created_at"),
                metadata,
                library_id: row.try_get("library_id").ok(),
                parent_media_id: row.try_get("parent_media_id").ok(),
            });
        }

        Ok(media_files)
    }

    async fn get_stats(&self) -> Result<MediaStats> {
        debug!("Retrieving media statistics");

        let total_row = sqlx::query!(
            "SELECT COUNT(*) as count, COALESCE(SUM(file_size), 0) as total_size FROM media_files"
        )
        .fetch_one(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to get stats: {e}")))?;

        let type_rows = sqlx::query!(
            "SELECT media_type, COUNT(*) as count FROM media_files GROUP BY media_type"
        )
        .fetch_all(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to get type stats: {e}")))?;

        let mut by_type = HashMap::new();
        for row in type_rows {
            if let Some(media_type) = row.media_type {
                by_type.insert(media_type, row.count.unwrap_or(0) as u64);
            }
        }

        Ok(MediaStats {
            total_files: total_row.count.unwrap_or(0) as u64,
            total_size: total_row
                .total_size
                .map(|v| {
                    use sqlx::types::BigDecimal;
                    let big_dec: BigDecimal = v;
                    big_dec.to_string().parse::<u64>().unwrap_or(0)
                })
                .unwrap_or(0),
            by_type,
        })
    }

    async fn file_exists(&self, path: &str) -> Result<bool> {
        let result = sqlx::query!(
            "SELECT EXISTS(SELECT 1 FROM media_files WHERE file_path = $1) as exists",
            path
        )
        .fetch_one(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to check file existence: {e}")))?;

        Ok(result.exists.unwrap_or(false))
    }

    async fn store_external_metadata(
        &self,
        media_id: &str,
        metadata: &MediaMetadata,
    ) -> Result<()> {
        if let Some(external) = &metadata.external_info {
            // Strip "media:" prefix if present
            let uuid_str = if media_id.starts_with("media:") {
                media_id.strip_prefix("media:").unwrap_or(media_id)
            } else {
                media_id
            };

            let uuid = Uuid::parse_str(uuid_str)
                .map_err(|e| MediaError::InvalidMedia(format!("Invalid UUID: {e}")))?;

            let title = external
                .description
                .as_ref()
                .map(|d| d.chars().take(100).collect::<String>())
                .unwrap_or_else(|| "Unknown".to_string());

            // Store genres as JSONB
            let genres_json = if !external.genres.is_empty() {
                Some(serde_json::to_value(&external.genres).unwrap_or(serde_json::Value::Null))
            } else {
                None
            };

            sqlx::query!(
                r#"
                INSERT INTO external_metadata (
                    media_file_id, source, external_id, title, overview, release_date,
                    vote_average, poster_path, backdrop_path, genres,
                    show_description, show_poster_path, season_poster_path, episode_still_path
                )
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
                ON CONFLICT (media_file_id, source) DO UPDATE
                SET external_id = EXCLUDED.external_id,
                    title = EXCLUDED.title,
                    overview = EXCLUDED.overview,
                    poster_path = EXCLUDED.poster_path,
                    backdrop_path = EXCLUDED.backdrop_path,
                    genres = EXCLUDED.genres,
                    vote_average = EXCLUDED.vote_average,
                    show_description = EXCLUDED.show_description,
                    show_poster_path = EXCLUDED.show_poster_path,
                    season_poster_path = EXCLUDED.season_poster_path,
                    episode_still_path = EXCLUDED.episode_still_path,
                    updated_at = NOW()
                "#,
                uuid,
                "tmdb", // source
                external
                    .tmdb_id
                    .map(|id| id.to_string())
                    .unwrap_or_else(|| "unknown".to_string()), // external_id (required)
                title,
                external.description.as_deref(),
                external.release_date,
                external.rating.map(|r| {
                    use sqlx::types::BigDecimal;
                    use std::str::FromStr;
                    BigDecimal::from_str(&r.to_string()).unwrap_or_default()
                }),
                external.poster_url.as_deref(),
                external.backdrop_url.as_deref(),
                genres_json,
                external.show_description.as_deref(),
                external.show_poster_url.as_deref(),
                external.season_poster_url.as_deref(),
                external.episode_still_url.as_deref()
            )
            .execute(&self.pool)
            .await
            .map_err(|e| {
                MediaError::InvalidMedia(format!("Failed to store external metadata: {e}"))
            })?;
        }

        Ok(())
    }

    async fn store_tv_show(&self, show_info: &TvShowInfo) -> Result<String> {
        sqlx::query!(
            r#"
            INSERT INTO tv_shows (id, tmdb_id, name, overview, poster_path, backdrop_path)
            VALUES ($1, $2, $3, $4, $5, $6)
            ON CONFLICT (tmdb_id) DO UPDATE
            SET name = EXCLUDED.name,
                overview = EXCLUDED.overview,
                updated_at = NOW()
            RETURNING id
            "#,
            show_info.id,
            show_info.tmdb_id.parse::<i32>().ok(),
            show_info.name,
            show_info.overview.as_deref(),
            show_info.poster_path.as_deref(),
            show_info.backdrop_path.as_deref()
        )
        .fetch_one(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to store TV show: {e}")))?;

        for season in &show_info.seasons {
            sqlx::query!(
                r#"
                INSERT INTO tv_seasons (id, tv_show_id, season_number, name, episode_count, poster_path)
                VALUES ($1, $2, $3, $4, $5, $6)
                ON CONFLICT (tv_show_id, season_number) DO UPDATE
                SET name = EXCLUDED.name,
                    episode_count = EXCLUDED.episode_count,
                    updated_at = NOW()
                "#,
                season.id,
                show_info.id,
                season.season_number,
                season.name.as_deref(),
                season.episode_count,
                season.poster_path.as_deref()
            )
            .execute(&self.pool)
            .await
            .map_err(|e| MediaError::InvalidMedia(format!("Failed to store season: {e}")))?;
        }

        Ok(show_info.id.to_string())
    }

    async fn get_tv_show(&self, tmdb_id: &str) -> Result<Option<TvShowInfo>> {
        let tmdb_id_int = tmdb_id.parse::<i32>()
            .map_err(|_| MediaError::InvalidMedia(format!("Invalid TMDB ID: {}", tmdb_id)))?;

        let show_row = sqlx::query!(
            "SELECT id, tmdb_id, name, overview, poster_path, backdrop_path FROM tv_shows WHERE tmdb_id = $1",
            tmdb_id_int
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to get TV show: {e}")))?;

        if let Some(show) = show_row {
            let seasons = sqlx::query!(
                "SELECT id, season_number, name, episode_count, poster_path FROM tv_seasons WHERE tv_show_id = $1 ORDER BY season_number",
                show.id
            )
            .fetch_all(&self.pool)
            .await
            .map_err(|e| MediaError::InvalidMedia(format!("Failed to get seasons: {e}")))?
            .into_iter()
            .map(|s| SeasonInfo {
                id: s.id,
                season_number: s.season_number,
                name: s.name,
                episode_count: s.episode_count.unwrap_or(0),
                poster_path: s.poster_path,
            })
            .collect();

            Ok(Some(TvShowInfo {
                id: show.id,
                tmdb_id: show.tmdb_id.map(|id| id.to_string()).unwrap_or_default(),
                name: show.name,
                overview: show.overview,
                poster_path: show.poster_path,
                backdrop_path: show.backdrop_path,
                seasons,
            }))
        } else {
            Ok(None)
        }
    }

    async fn link_episode_to_file(
        &self,
        media_file_id: &str,
        show_tmdb_id: &str,
        season: i32,
        episode: i32,
    ) -> Result<()> {
        // Strip "media:" prefix if present
        let uuid_str = if media_file_id.starts_with("media:") {
            media_file_id
                .strip_prefix("media:")
                .unwrap_or(media_file_id)
        } else {
            media_file_id
        };

        let file_uuid = Uuid::parse_str(uuid_str)
            .map_err(|e| MediaError::InvalidMedia(format!("Invalid file UUID: {e}")))?;

        let tmdb_id_int = show_tmdb_id.parse::<i32>()
            .map_err(|_| MediaError::InvalidMedia(format!("Invalid TMDB ID: {}", show_tmdb_id)))?;

        sqlx::query!(
            r#"
            UPDATE tv_episodes
            SET media_file_id = $1
            WHERE tv_show_id = (SELECT id FROM tv_shows WHERE tmdb_id = $2)
              AND season_number = $3
              AND episode_number = $4
            "#,
            file_uuid,
            tmdb_id_int,
            season,
            episode
        )
        .execute(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to link episode to file: {e}")))?;

        Ok(())
    }

    async fn delete_media(&self, id: &str) -> Result<()> {
        // Strip "media:" prefix if present
        let uuid_str = if id.starts_with("media:") {
            id.strip_prefix("media:").unwrap_or(id)
        } else {
            id
        };

        let uuid = Uuid::parse_str(uuid_str)
            .map_err(|e| MediaError::InvalidMedia(format!("Invalid UUID: {e}")))?;

        sqlx::query!("DELETE FROM media_files WHERE id = $1", uuid)
            .execute(&self.pool)
            .await
            .map_err(|e| MediaError::InvalidMedia(format!("Failed to delete media: {e}")))?;

        Ok(())
    }

    async fn get_all_media(&self) -> Result<Vec<MediaFile>> {
        let rows = sqlx::query(
            r#"
            SELECT
                mf.id, mf.file_path, mf.file_name, mf.file_size, mf.created_at, mf.library_id, mf.parent_media_id,
                mm.duration_seconds, mm.width, mm.height, mm.video_codec, mm.audio_codec,
                mm.parsed_info, mm.bit_depth, mm.color_transfer, mm.color_space, mm.color_primaries,
                em.external_id, em.title, em.overview, em.release_date,
                em.vote_average, em.poster_path, em.backdrop_path, em.genres,
                em.show_description, em.show_poster_path, em.season_poster_path, em.episode_still_path
            FROM media_files mf
            LEFT JOIN media_metadata mm ON mf.id = mm.media_file_id
            LEFT JOIN external_metadata em ON mf.id = em.media_file_id
            ORDER BY mf.created_at DESC
            "#
        )
        .fetch_all(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to fetch all media: {e}")))?;

        let mut media_files = Vec::new();
        for row in rows {
            media_files.push(self.row_to_media_file(row));
        }

        Ok(media_files)
    }

    // Library management methods
    async fn create_library(&self, library: crate::Library) -> Result<String> {
        let paths: Vec<String> = library.paths.iter()
            .map(|p| p.to_string_lossy().to_string())
            .collect();

        let id: (Uuid,) = sqlx::query_as(
            r#"
            INSERT INTO libraries (id, name, library_type, paths, scan_interval_minutes, enabled, created_at, updated_at)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
            RETURNING id
            "#
        )
        .bind(library.id)
        .bind(&library.name)
        .bind(format!("{:?}", library.library_type))
        .bind(&paths)
        .bind(library.scan_interval_minutes as i32)
        .bind(library.enabled)
        .bind(library.created_at)
        .bind(library.updated_at)
        .fetch_one(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to create library: {e}")))?;

        Ok(id.0.to_string())
    }

    async fn get_library(&self, id: &str) -> Result<Option<crate::Library>> {
        let uuid = Uuid::parse_str(id)
            .map_err(|e| MediaError::InvalidMedia(format!("Invalid UUID: {e}")))?;

        let row = sqlx::query(
            r#"
            SELECT id, name, library_type, paths, scan_interval_minutes, last_scan, enabled, created_at, updated_at
            FROM libraries
            WHERE id = $1
            "#
        )
        .bind(uuid)
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to get library: {e}")))?;

        match row {
            Some(row) => {
                let library_type_str: String = row.get("library_type");
                let library_type = match library_type_str.as_str() {
                    "Movies" => crate::LibraryType::Movies,
                    "TvShows" => crate::LibraryType::TvShows,
                    _ => crate::LibraryType::Movies, // Default
                };

                let paths: Vec<String> = row.get("paths");
                let paths = paths.into_iter()
                    .map(std::path::PathBuf::from)
                    .collect();

                Ok(Some(crate::Library {
                    id: row.get("id"),
                    name: row.get("name"),
                    library_type,
                    paths,
                    scan_interval_minutes: row.get::<i32, _>("scan_interval_minutes") as u32,
                    last_scan: row.get("last_scan"),
                    enabled: row.get("enabled"),
                    created_at: row.get("created_at"),
                    updated_at: row.get("updated_at"),
                }))
            }
            None => Ok(None)
        }
    }

    async fn list_libraries(&self) -> Result<Vec<crate::Library>> {
        let rows = sqlx::query(
            r#"
            SELECT id, name, library_type, paths, scan_interval_minutes, last_scan, enabled, created_at, updated_at
            FROM libraries
            ORDER BY name
            "#
        )
        .fetch_all(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to list libraries: {e}")))?;

        let libraries = rows.into_iter().map(|row| {
            let library_type_str: String = row.get("library_type");
            let library_type = match library_type_str.as_str() {
                "Movies" => crate::LibraryType::Movies,
                "TvShows" => crate::LibraryType::TvShows,
                _ => crate::LibraryType::Movies,
            };

            let paths: Vec<String> = row.get("paths");
            let paths = paths.into_iter()
                .map(std::path::PathBuf::from)
                .collect();

            crate::Library {
                id: row.get("id"),
                name: row.get("name"),
                library_type,
                paths,
                scan_interval_minutes: row.get::<i32, _>("scan_interval_minutes") as u32,
                last_scan: row.get("last_scan"),
                enabled: row.get("enabled"),
                created_at: row.get("created_at"),
                updated_at: row.get("updated_at"),
            }
        }).collect();

        Ok(libraries)
    }

    async fn update_library(&self, id: &str, library: crate::Library) -> Result<()> {
        let uuid = Uuid::parse_str(id)
            .map_err(|e| MediaError::InvalidMedia(format!("Invalid UUID: {e}")))?;

        let paths: Vec<String> = library.paths.iter()
            .map(|p| p.to_string_lossy().to_string())
            .collect();

        sqlx::query(
            r#"
            UPDATE libraries
            SET name = $2, paths = $3, scan_interval_minutes = $4, enabled = $5, updated_at = NOW()
            WHERE id = $1
            "#
        )
        .bind(uuid)
        .bind(library.name)
        .bind(&paths)
        .bind(library.scan_interval_minutes as i32)
        .bind(library.enabled)
        .execute(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to update library: {e}")))?;

        Ok(())
    }

    async fn delete_library(&self, id: &str) -> Result<()> {
        let uuid = Uuid::parse_str(id)
            .map_err(|e| MediaError::InvalidMedia(format!("Invalid UUID: {e}")))?;

        // Start a transaction to ensure both operations succeed or fail together
        let mut tx = self.pool.begin().await
            .map_err(|e| MediaError::InvalidMedia(format!("Failed to start transaction: {e}")))?;

        // First, delete all media files associated with this library
        sqlx::query("DELETE FROM media_files WHERE library_id = $1")
            .bind(uuid)
            .execute(&mut *tx)
            .await
            .map_err(|e| MediaError::InvalidMedia(format!("Failed to delete media files: {e}")))?;

        // Then delete the library itself
        sqlx::query("DELETE FROM libraries WHERE id = $1")
            .bind(uuid)
            .execute(&mut *tx)
            .await
            .map_err(|e| MediaError::InvalidMedia(format!("Failed to delete library: {e}")))?;

        // Commit the transaction
        tx.commit().await
            .map_err(|e| MediaError::InvalidMedia(format!("Failed to commit transaction: {e}")))?;

        Ok(())
    }

    async fn update_library_last_scan(&self, id: &str) -> Result<()> {
        let uuid = Uuid::parse_str(id)
            .map_err(|e| MediaError::InvalidMedia(format!("Invalid UUID: {e}")))?;

        sqlx::query(
            r#"
            UPDATE libraries
            SET last_scan = NOW(), updated_at = NOW()
            WHERE id = $1
            "#
        )
        .bind(uuid)
        .execute(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to update library last scan: {e}")))?;

        Ok(())
    }

    // New reference type methods
    async fn store_movie_reference(&self, movie: &MovieReference) -> Result<()> {
        // First store the media file
        self.store_media(movie.file.clone()).await?;

        // Then store the movie reference
        let library_id = movie.file.library_id
            .ok_or_else(|| MediaError::InvalidMedia("Movie file must have library_id".to_string()))?;

        sqlx::query!(
            r#"
            INSERT INTO movie_references (id, tmdb_id, title, file_id, library_id)
            VALUES ($1, $2, $3, $4, $5)
            ON CONFLICT (id) DO UPDATE
            SET tmdb_id = EXCLUDED.tmdb_id,
                title = EXCLUDED.title,
                file_id = EXCLUDED.file_id,
                library_id = EXCLUDED.library_id,
                updated_at = NOW()
            "#,
            Uuid::parse_str(movie.id.as_str())?,
            movie.tmdb_id as i64,
            movie.title.as_str(),
            movie.file.id,
            library_id
        )
        .execute(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to store movie reference: {}", e)))?;

        Ok(())
    }

    async fn store_series_reference(&self, series: &SeriesReference) -> Result<()> {
        // Get library_id from the first episode that references this series
        let library_id = sqlx::query!(
            r#"
            SELECT DISTINCT mf.library_id
            FROM episode_references er
            JOIN media_files mf ON er.file_id = mf.id
            WHERE er.series_id = $1
            LIMIT 1
            "#,
            Uuid::parse_str(series.id.as_str())?
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to get library_id for series: {}", e)))?
        .and_then(|row| row.library_id)
        .ok_or_else(|| MediaError::InvalidMedia("Series must be associated with a library".to_string()))?;

        sqlx::query!(
            r#"
            INSERT INTO series_references (id, tmdb_id, title, library_id)
            VALUES ($1, $2, $3, $4)
            ON CONFLICT (id) DO UPDATE
            SET tmdb_id = EXCLUDED.tmdb_id,
                title = EXCLUDED.title,
                library_id = EXCLUDED.library_id,
                updated_at = NOW()
            "#,
            Uuid::parse_str(series.id.as_str())?,
            series.tmdb_id as i64,
            series.title.as_str(),
            library_id
        )
        .execute(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to store series reference: {}", e)))?;

        Ok(())
    }

    async fn store_season_reference(&self, season: &SeasonReference) -> Result<()> {
        sqlx::query!(
            r#"
            INSERT INTO season_references (id, season_number, series_id, tmdb_series_id)
            VALUES ($1, $2, $3, $4)
            ON CONFLICT (id) DO UPDATE
            SET season_number = EXCLUDED.season_number,
                series_id = EXCLUDED.series_id,
                tmdb_series_id = EXCLUDED.tmdb_series_id,
                updated_at = NOW()
            "#,
            Uuid::parse_str(season.id.as_str())?,
            season.season_number.value() as i16,
            Uuid::parse_str(season.series_id.as_str())?,
            season.tmdb_series_id as i64
        )
        .execute(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to store season reference: {}", e)))?;

        Ok(())
    }

    async fn store_episode_reference(&self, episode: &EpisodeReference) -> Result<()> {
        // First store the media file
        self.store_media(episode.file.clone()).await?;

        let library_id = episode.file.library_id
            .ok_or_else(|| MediaError::InvalidMedia("Episode file must have library_id".to_string()))?;

        // Then store the episode reference
        sqlx::query!(
            r#"
            INSERT INTO episode_references (
                id, episode_number, season_number, season_id, series_id,
                tmdb_series_id, file_id, library_id
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
            ON CONFLICT (id) DO UPDATE
            SET episode_number = EXCLUDED.episode_number,
                season_number = EXCLUDED.season_number,
                season_id = EXCLUDED.season_id,
                series_id = EXCLUDED.series_id,
                tmdb_series_id = EXCLUDED.tmdb_series_id,
                file_id = EXCLUDED.file_id,
                library_id = EXCLUDED.library_id,
                updated_at = NOW()
            "#,
            Uuid::parse_str(episode.id.as_str())?,
            episode.episode_number.value() as i16,
            episode.season_number.value() as i16,
            Uuid::parse_str(episode.season_id.as_str())?,
            Uuid::parse_str(episode.series_id.as_str())?,
            episode.tmdb_series_id as i64,
            episode.file.id,
            library_id
        )
        .execute(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to store episode reference: {}", e)))?;

        Ok(())
    }

    async fn get_all_movie_references(&self) -> Result<Vec<MovieReference>> {
        let rows = sqlx::query!(
            r#"
            SELECT mr.*, mf.id as file_id
            FROM movie_references mr
            JOIN media_files mf ON mr.file_id = mf.id
            ORDER BY mr.title
            "#
        )
        .fetch_all(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to get all movie references: {}", e)))?;

        let mut movies = Vec::new();
        for row in rows {
            if let Some(media_file) = self.get_media(&row.file_id.to_string()).await? {
                movies.push(MovieReference {
                    id: MovieID::new(row.id.to_string())?,
                    tmdb_id: row.tmdb_id as u64,
                    title: MovieTitle::new(row.title)?,
                    details: MediaDetailsOption::Endpoint(
                        url::Url::parse(&format!("/api/movie/{}", row.id))
                            .map_err(|e| MediaError::InvalidMedia(format!("Invalid URL: {}", e)))?
                    ),
                    endpoint: MovieURL::new(
                        url::Url::parse(&format!("/api/stream/{}", row.file_id))
                            .map_err(|e| MediaError::InvalidMedia(format!("Invalid URL: {}", e)))?
                    ),
                    file: media_file,
                });
            }
        }

        Ok(movies)
    }

    async fn get_series_references(&self) -> Result<Vec<SeriesReference>> {
        let rows = sqlx::query!(
            r#"
            SELECT sr.*
            FROM series_references sr
            ORDER BY sr.title
            "#
        )
        .fetch_all(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to get series references: {}", e)))?;

        let mut series_list = Vec::new();
        for row in rows {
            series_list.push(SeriesReference {
                id: SeriesID::new(row.id.to_string())?,
                tmdb_id: row.tmdb_id as u64,
                title: SeriesTitle::new(row.title)?,
                details: MediaDetailsOption::Endpoint(
                    url::Url::parse(&format!("/api/series/{}", row.id))
                        .map_err(|e| MediaError::InvalidMedia(format!("Invalid URL: {}", e)))?
                ),
                endpoint: SeriesURL::new(
                    url::Url::parse(&format!("/api/series/{}", row.id))
                        .map_err(|e| MediaError::InvalidMedia(format!("Invalid URL: {}", e)))?
                ),
            });
        }

        Ok(series_list)
    }

    async fn get_series_seasons(&self, series_id: &SeriesID) -> Result<Vec<SeasonReference>> {
        let rows = sqlx::query!(
            r#"
            SELECT sr.*
            FROM season_references sr
            WHERE sr.series_id = $1
            ORDER BY sr.season_number
            "#,
            Uuid::parse_str(series_id.as_str())?
        )
        .fetch_all(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to get series seasons: {}", e)))?;

        let mut seasons = Vec::new();
        for row in rows {
            seasons.push(SeasonReference {
                id: SeasonID::new(row.id.to_string())?,
                season_number: SeasonNumber::new(row.season_number as u8),
                series_id: SeriesID::new(row.series_id.to_string())?,
                tmdb_series_id: row.tmdb_series_id as u64,
                details: MediaDetailsOption::Endpoint(
                    url::Url::parse(&format!("/api/season/{}", row.id))
                        .map_err(|e| MediaError::InvalidMedia(format!("Invalid URL: {}", e)))?
                ),
                endpoint: SeasonURL::new(
                    url::Url::parse(&format!("/api/season/{}", row.id))
                        .map_err(|e| MediaError::InvalidMedia(format!("Invalid URL: {}", e)))?
                ),
            });
        }

        Ok(seasons)
    }

    async fn get_season_episodes(&self, season_id: &SeasonID) -> Result<Vec<EpisodeReference>> {
        let rows = sqlx::query!(
            r#"
            SELECT er.*, mf.id as file_id
            FROM episode_references er
            JOIN media_files mf ON er.file_id = mf.id
            WHERE er.season_id = $1
            ORDER BY er.episode_number
            "#,
            Uuid::parse_str(season_id.as_str())?
        )
        .fetch_all(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to get season episodes: {}", e)))?;

        let mut episodes = Vec::new();
        for row in rows {
            if let Some(media_file) = self.get_media(&row.file_id.to_string()).await? {
                episodes.push(EpisodeReference {
                    id: EpisodeID::new(row.id.to_string())?,
                    episode_number: EpisodeNumber::new(row.episode_number as u8),
                    season_number: SeasonNumber::new(row.season_number as u8),
                    season_id: SeasonID::new(row.season_id.to_string())?,
                    series_id: SeriesID::new(row.series_id.to_string())?,
                    tmdb_series_id: row.tmdb_series_id as u64,
                    details: MediaDetailsOption::Endpoint(
                        url::Url::parse(&format!("/api/episode/{}", row.id))
                            .map_err(|e| MediaError::InvalidMedia(format!("Invalid URL: {}", e)))?
                    ),
                    endpoint: EpisodeURL::new(
                        url::Url::parse(&format!("/api/stream/{}", row.file_id))
                            .map_err(|e| MediaError::InvalidMedia(format!("Invalid URL: {}", e)))?
                    ),
                    file: media_file,
                });
            }
        }

        Ok(episodes)
    }

    async fn get_library_movies(&self, library_id: LibraryID) -> Result<Vec<MovieReference>> {
        let rows = sqlx::query!(
            r#"
            SELECT mr.*, mf.id as file_id
            FROM movie_references mr
            JOIN media_files mf ON mr.file_id = mf.id
            WHERE mr.library_id = $1
            ORDER BY mr.title
            "#,
            library_id
        )
        .fetch_all(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to get library movies: {}", e)))?;

        let mut movies = Vec::new();
        for row in rows {
            if let Some(media_file) = self.get_media(&row.file_id.to_string()).await? {
                movies.push(MovieReference {
                    id: MovieID::new(row.id.to_string())?,
                    tmdb_id: row.tmdb_id as u64,
                    title: MovieTitle::new(row.title)?,
                    details: MediaDetailsOption::Endpoint(
                        url::Url::parse(&format!("/api/movie/{}", row.id))
                            .map_err(|e| MediaError::InvalidMedia(format!("Invalid URL: {}", e)))?
                    ),
                    endpoint: MovieURL::new(
                        url::Url::parse(&format!("/api/stream/{}", row.file_id))
                            .map_err(|e| MediaError::InvalidMedia(format!("Invalid URL: {}", e)))?
                    ),
                    file: media_file,
                });
            }
        }

        Ok(movies)
    }

    async fn get_library_series(&self, library_id: LibraryID) -> Result<Vec<SeriesReference>> {
        let rows = sqlx::query!(
            r#"
            SELECT DISTINCT sr.*
            FROM series_references sr
            WHERE sr.library_id = $1
            ORDER BY sr.title
            "#,
            library_id
        )
        .fetch_all(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to get library series: {}", e)))?;

        let mut series_list = Vec::new();
        for row in rows {
            series_list.push(SeriesReference {
                id: SeriesID::new(row.id.to_string())?,
                tmdb_id: row.tmdb_id as u64,
                title: SeriesTitle::new(row.title)?,
                details: MediaDetailsOption::Endpoint(
                    url::Url::parse(&format!("/api/series/{}", row.id))
                        .map_err(|e| MediaError::InvalidMedia(format!("Invalid URL: {}", e)))?
                ),
                endpoint: SeriesURL::new(
                    url::Url::parse(&format!("/api/series/{}", row.id))
                        .map_err(|e| MediaError::InvalidMedia(format!("Invalid URL: {}", e)))?
                ),
            });
        }

        Ok(series_list)
    }

    async fn get_movie_reference(&self, id: &MovieID) -> Result<MovieReference> {
        let row = sqlx::query!(
            r#"
            SELECT mr.*, mf.id as file_id
            FROM movie_references mr
            JOIN media_files mf ON mr.file_id = mf.id
            WHERE mr.id = $1
            "#,
            Uuid::parse_str(id.as_str())?
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to get movie reference: {}", e)))?
        .ok_or_else(|| MediaError::NotFound("Movie reference not found".to_string()))?;

        let media_file = self.get_media(&row.file_id.to_string()).await?
            .ok_or_else(|| MediaError::NotFound("Media file not found".to_string()))?;

        Ok(MovieReference {
            id: MovieID::new(row.id.to_string())?,
            tmdb_id: row.tmdb_id as u64,
            title: MovieTitle::new(row.title)?,
            details: MediaDetailsOption::Endpoint(
                url::Url::parse(&format!("/api/movie/{}", row.id))
                    .map_err(|e| MediaError::InvalidMedia(format!("Invalid URL: {}", e)))?
            ),
            endpoint: MovieURL::new(
                url::Url::parse(&format!("/api/stream/{}", row.file_id))
                    .map_err(|e| MediaError::InvalidMedia(format!("Invalid URL: {}", e)))?
            ),
            file: media_file,
        })
    }

    async fn get_series_reference(&self, id: &SeriesID) -> Result<SeriesReference> {
        let row = sqlx::query!(
            r#"
            SELECT sr.*
            FROM series_references sr
            WHERE sr.id = $1
            "#,
            Uuid::parse_str(id.as_str())?
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to get series reference: {}", e)))?
        .ok_or_else(|| MediaError::NotFound("Series reference not found".to_string()))?;

        Ok(SeriesReference {
            id: SeriesID::new(row.id.to_string())?,
            tmdb_id: row.tmdb_id as u64,
            title: SeriesTitle::new(row.title)?,
            details: MediaDetailsOption::Endpoint(
                url::Url::parse(&format!("/api/series/{}", row.id))
                    .map_err(|e| MediaError::InvalidMedia(format!("Invalid URL: {}", e)))?
            ),
            endpoint: SeriesURL::new(
                url::Url::parse(&format!("/api/series/{}", row.id))
                    .map_err(|e| MediaError::InvalidMedia(format!("Invalid URL: {}", e)))?
            ),
        })
    }

    async fn get_season_reference(&self, id: &SeasonID) -> Result<SeasonReference> {
        let row = sqlx::query!(
            r#"
            SELECT sr.*
            FROM season_references sr
            WHERE sr.id = $1
            "#,
            Uuid::parse_str(id.as_str())?
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to get season reference: {}", e)))?
        .ok_or_else(|| MediaError::NotFound("Season reference not found".to_string()))?;

        Ok(SeasonReference {
            id: SeasonID::new(row.id.to_string())?,
            season_number: SeasonNumber::new(row.season_number as u8),
            series_id: SeriesID::new(row.series_id.to_string())?,
            tmdb_series_id: row.tmdb_series_id as u64,
            details: MediaDetailsOption::Endpoint(
                url::Url::parse(&format!("/api/season/{}", row.id))
                    .map_err(|e| MediaError::InvalidMedia(format!("Invalid URL: {}", e)))?
            ),
            endpoint: SeasonURL::new(
                url::Url::parse(&format!("/api/season/{}", row.id))
                    .map_err(|e| MediaError::InvalidMedia(format!("Invalid URL: {}", e)))?
            ),
        })
    }

    async fn get_episode_reference(&self, id: &EpisodeID) -> Result<EpisodeReference> {
        let row = sqlx::query!(
            r#"
            SELECT er.*, mf.id as file_id
            FROM episode_references er
            JOIN media_files mf ON er.file_id = mf.id
            WHERE er.id = $1
            "#,
            Uuid::parse_str(id.as_str())?
        )
        .fetch_optional(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to get episode reference: {}", e)))?
        .ok_or_else(|| MediaError::NotFound("Episode reference not found".to_string()))?;

        let media_file = self.get_media(&row.file_id.to_string()).await?
            .ok_or_else(|| MediaError::NotFound("Media file not found".to_string()))?;

        Ok(EpisodeReference {
            id: EpisodeID::new(row.id.to_string())?,
            episode_number: EpisodeNumber::new(row.episode_number as u8),
            season_number: SeasonNumber::new(row.season_number as u8),
            season_id: SeasonID::new(row.season_id.to_string())?,
            series_id: SeriesID::new(row.series_id.to_string())?,
            tmdb_series_id: row.tmdb_series_id as u64,
            details: MediaDetailsOption::Endpoint(
                url::Url::parse(&format!("/api/episode/{}", row.id))
                    .map_err(|e| MediaError::InvalidMedia(format!("Invalid URL: {}", e)))?
            ),
            endpoint: EpisodeURL::new(
                url::Url::parse(&format!("/api/stream/{}", row.file_id))
                    .map_err(|e| MediaError::InvalidMedia(format!("Invalid URL: {}", e)))?
            ),
            file: media_file,
        })
    }

    async fn update_movie_tmdb_id(&self, id: &MovieID, tmdb_id: u64) -> Result<()> {
        sqlx::query!(
            r#"
            UPDATE movie_references
            SET tmdb_id = $1, updated_at = NOW()
            WHERE id = $2
            "#,
            tmdb_id as i64,
            Uuid::parse_str(id.as_str())?
        )
        .execute(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to update movie TMDB ID: {}", e)))?;

        Ok(())
    }

    async fn update_series_tmdb_id(&self, id: &SeriesID, tmdb_id: u64) -> Result<()> {
        // Update series
        sqlx::query!(
            r#"
            UPDATE series_references
            SET tmdb_id = $1, updated_at = NOW()
            WHERE id = $2
            "#,
            tmdb_id as i64,
            Uuid::parse_str(id.as_str())?
        )
        .execute(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to update series TMDB ID: {}", e)))?;

        // Update related seasons and episodes
        sqlx::query!(
            r#"
            UPDATE season_references
            SET tmdb_series_id = $1, updated_at = NOW()
            WHERE series_id = $2
            "#,
            tmdb_id as i64,
            Uuid::parse_str(id.as_str())?
        )
        .execute(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to update season TMDB IDs: {}", e)))?;

        sqlx::query!(
            r#"
            UPDATE episode_references
            SET tmdb_series_id = $1, updated_at = NOW()
            WHERE series_id = $2
            "#,
            tmdb_id as i64,
            Uuid::parse_str(id.as_str())?
        )
        .execute(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to update episode TMDB IDs: {}", e)))?;

        Ok(())
    }

    async fn list_library_references(&self) -> Result<Vec<LibraryReference>> {
        let rows = sqlx::query!(
            r#"
            SELECT id, name, library_type, paths
            FROM libraries
            ORDER BY name
            "#
        )
        .fetch_all(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to list libraries: {}", e)))?;

        let mut libraries = Vec::new();
        for row in rows {
            let paths = serde_json::from_value::<Vec<PathBuf>>(row.paths)
                .unwrap_or_else(|_| vec![]);

            libraries.push(LibraryReference {
                id: row.id,
                name: row.name,
                library_type: match row.library_type.as_str() {
                    "movies" => crate::LibraryType::Movies,
                    "tvshows" => crate::LibraryType::TvShows,
                    _ => crate::LibraryType::Movies,
                },
                paths,
            });
        }

        Ok(libraries)
    }

    async fn get_library_reference(&self, id: Uuid) -> Result<LibraryReference> {
        let row = sqlx::query!(
            r#"
            SELECT id, name, library_type, paths
            FROM libraries
            WHERE id = $1
            "#,
            id
        )
        .fetch_one(&self.pool)
        .await
        .map_err(|e| MediaError::InvalidMedia(format!("Failed to get library: {}", e)))?;

        let paths = serde_json::from_value::<Vec<PathBuf>>(row.paths)
            .unwrap_or_else(|_| vec![]);

        Ok(LibraryReference {
            id: row.id,
            name: row.name,
            library_type: match row.library_type.as_str() {
                "movies" => crate::LibraryType::Movies,
                "tvshows" => crate::LibraryType::TvShows,
                _ => crate::LibraryType::Movies,
            },
            paths,
        })
    }
}
