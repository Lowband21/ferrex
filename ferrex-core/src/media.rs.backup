use crate::{MediaError, api_types::MediaId};
use serde::{Deserialize, Serialize};
use std::path::PathBuf;
use std::time::Duration;
use url::Url;
use uuid::Uuid;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MediaFile {
    pub id: Uuid,
    pub path: PathBuf,
    pub filename: String,
    pub size: u64,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub media_file_metadata: Option<MediaFileMetadata>,
    pub library_id: Uuid,
}

impl Default for MediaFile {
    fn default() -> Self {
        Self {
            id: Uuid::new_v4(),
            path: PathBuf::new(),
            filename: String::new(),
            size: 0,
            created_at: chrono::Utc::now(),
            media_file_metadata: None,
            library_id: Uuid::nil(), // Use nil UUID for default
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MediaFileMetadata {
    // Technical metadata from FFmpeg
    pub duration: Option<f64>,
    pub width: Option<u32>,
    pub height: Option<u32>,
    pub video_codec: Option<String>,
    pub audio_codec: Option<String>,
    pub bitrate: Option<u64>,
    pub framerate: Option<f64>,
    pub file_size: u64,

    // HDR metadata
    pub color_primaries: Option<String>,
    pub color_transfer: Option<String>,
    pub color_space: Option<String>,
    pub bit_depth: Option<u32>,

    // Parsed from filename
    pub parsed_info: Option<ParsedMediaInfo>,
}
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ParsedMediaInfo {
    Movie(ParsedMovieInfo),
    Episode(ParsedEpisodeInfo),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ParsedMovieInfo {
    pub title: String,
    pub year: Option<u16>,
    pub resolution: Option<String>,
    pub source: Option<String>,
    pub release_group: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ParsedEpisodeInfo {
    pub show_name: String,
    pub season: u32,
    pub episode: u32,
    pub episode_title: Option<String>,
    pub year: Option<u16>,
    pub resolution: Option<String>,
    pub source: Option<String>,
    pub release_group: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "PascalCase")]
pub enum ExtraType {
    BehindTheScenes,
    DeletedScenes,
    Featurette,
    Interview,
    Scene,
    Short,
    Trailer,
    Other,
}

impl std::fmt::Display for ExtraType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            ExtraType::BehindTheScenes => write!(f, "Behind the Scenes"),
            ExtraType::DeletedScenes => write!(f, "Deleted Scenes"),
            ExtraType::Featurette => write!(f, "Featurette"),
            ExtraType::Interview => write!(f, "Interview"),
            ExtraType::Scene => write!(f, "Scene"),
            ExtraType::Short => write!(f, "Short"),
            ExtraType::Trailer => write!(f, "Trailer"),
            ExtraType::Other => write!(f, "Other"),
        }
    }
}

impl MediaFile {
    pub fn new(path: PathBuf, library_id: Uuid) -> crate::Result<Self> {
        let filename = path
            .file_name()
            .ok_or_else(|| crate::MediaError::InvalidMedia("Invalid file path".to_string()))?
            .to_string_lossy()
            .to_string();

        let metadata = path.metadata()?;

        Ok(Self {
            id: Uuid::new_v4(),
            path,
            filename,
            size: metadata.len(),
            created_at: chrono::Utc::now(),
            media_file_metadata: None,
            library_id,
        })
    }

    /// Extract full metadata for this media file
    #[cfg(feature = "ffmpeg")]
    pub fn extract_metadata(&mut self) -> crate::Result<()> {
        let mut extractor = crate::MetadataExtractor::new();
        let metadata = extractor.extract_metadata(&self.path)?;
        self.media_file_metadata = Some(metadata);
        Ok(())
    }

    pub fn is_video_file(&self) -> bool {
        let video_extensions = ["mp4", "mkv", "avi", "mov", "webm", "flv", "wmv"];

        if let Some(extension) = self.path.extension() {
            if let Some(ext_str) = extension.to_str() {
                return video_extensions.contains(&ext_str.to_lowercase().as_str());
            }
        }

        false
    }
}
// Old placeholder types removed - see new implementation below

// We should have a library type that contains information about the library and at the very least some kind of index of the media it contains, if not the media types themselves
// We should have a Media wrapper type that can be either a Movie, Series, Season, or Episode, this will be sharable with the player
// Each of the types should have a specific type for metadata, Movie metadata, Series metadata, Season metadata, and Episode metadata, each their own types
// We should have a media endpoint type that is autovalidated and references the playback endpoint url
// Generally all unique types should have wrappers rather than just being strings so that we can have automatic input validation

// ===== NEW STRONGLY TYPED IDS AND REFERENCES =====

/// Strongly typed ID for movies with validation
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct MovieID(String);

impl MovieID {
    pub fn new(id: String) -> Result<Self, MediaError> {
        if id.is_empty() {
            return Err(MediaError::InvalidMedia(
                "Movie ID cannot be empty".to_string(),
            ));
        }
        Ok(MovieID(id))
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl std::fmt::Display for MovieID {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// Strongly typed ID for series with validation
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct SeriesID(String);

impl SeriesID {
    pub fn new(id: String) -> Result<Self, MediaError> {
        if id.is_empty() {
            return Err(MediaError::InvalidMedia(
                "Series ID cannot be empty".to_string(),
            ));
        }
        Ok(SeriesID(id))
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl std::fmt::Display for SeriesID {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// Strongly typed ID for seasons with validation
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct SeasonID(String);

impl SeasonID {
    pub fn new(id: String) -> Result<Self, MediaError> {
        if id.is_empty() {
            return Err(MediaError::InvalidMedia(
                "Season ID cannot be empty".to_string(),
            ));
        }
        Ok(SeasonID(id))
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl std::fmt::Display for SeasonID {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// Strongly typed ID for episodes with validation
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct EpisodeID(String);

impl EpisodeID {
    pub fn new(id: String) -> Result<Self, MediaError> {
        if id.is_empty() {
            return Err(MediaError::InvalidMedia(
                "Episode ID cannot be empty".to_string(),
            ));
        }
        Ok(EpisodeID(id))
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl std::fmt::Display for EpisodeID {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// Strongly typed ID for persons with validation
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct PersonID(String);

impl PersonID {
    pub fn new(id: String) -> Result<Self, MediaError> {
        if id.is_empty() {
            return Err(MediaError::InvalidMedia(
                "Person ID cannot be empty".to_string(),
            ));
        }
        Ok(PersonID(id))
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl std::fmt::Display for PersonID {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// Strongly typed movie title
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct MovieTitle(String);

impl MovieTitle {
    pub fn new(title: String) -> Result<Self, MediaError> {
        if title.is_empty() {
            return Err(MediaError::InvalidMedia(
                "Movie title cannot be empty".to_string(),
            ));
        }
        Ok(MovieTitle(title))
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl std::fmt::Display for MovieTitle {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl From<String> for MovieTitle {
    fn from(s: String) -> Self {
        MovieTitle(s)
    }
}

impl From<&str> for MovieTitle {
    fn from(s: &str) -> Self {
        MovieTitle(s.to_string())
    }
}

impl AsRef<str> for MovieTitle {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

impl std::hash::Hash for MovieTitle {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.0.hash(state);
    }
}

impl PartialOrd for MovieTitle {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for MovieTitle {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.0.cmp(&other.0)
    }
}

/// Strongly typed series title
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct SeriesTitle(String);

impl SeriesTitle {
    pub fn new(title: String) -> Result<Self, MediaError> {
        if title.is_empty() {
            return Err(MediaError::InvalidMedia(
                "Series title cannot be empty".to_string(),
            ));
        }
        Ok(SeriesTitle(title))
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl std::fmt::Display for SeriesTitle {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl From<String> for SeriesTitle {
    fn from(s: String) -> Self {
        SeriesTitle(s)
    }
}

impl From<&str> for SeriesTitle {
    fn from(s: &str) -> Self {
        SeriesTitle(s.to_string())
    }
}

impl AsRef<str> for SeriesTitle {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

impl std::hash::Hash for SeriesTitle {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.0.hash(state);
    }
}

impl PartialOrd for SeriesTitle {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for SeriesTitle {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.0.cmp(&other.0)
    }
}

/// Strongly typed episode title
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct EpisodeTitle(String);

impl EpisodeTitle {
    pub fn new(title: String) -> Result<Self, MediaError> {
        if title.is_empty() {
            return Err(MediaError::InvalidMedia(
                "Episode title cannot be empty".to_string(),
            ));
        }
        Ok(EpisodeTitle(title))
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl std::fmt::Display for EpisodeTitle {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl From<String> for EpisodeTitle {
    fn from(s: String) -> Self {
        EpisodeTitle(s)
    }
}

impl From<&str> for EpisodeTitle {
    fn from(s: &str) -> Self {
        EpisodeTitle(s.to_string())
    }
}

impl AsRef<str> for EpisodeTitle {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

impl std::hash::Hash for EpisodeTitle {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.0.hash(state);
    }
}

impl PartialOrd for EpisodeTitle {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for EpisodeTitle {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.0.cmp(&other.0)
    }
}

/// Season number with u8 bounds
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
pub struct SeasonNumber(u8);

impl SeasonNumber {
    pub fn new(num: u8) -> Self {
        SeasonNumber(num)
    }

    pub fn value(&self) -> u8 {
        self.0
    }
}

impl std::fmt::Display for SeasonNumber {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl From<u8> for SeasonNumber {
    fn from(num: u8) -> Self {
        SeasonNumber(num)
    }
}

impl Default for SeasonNumber {
    fn default() -> Self {
        SeasonNumber(1) // Season 1 is a reasonable default
    }
}

/// Episode number with u8 bounds
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
pub struct EpisodeNumber(u8);

impl EpisodeNumber {
    pub fn new(num: u8) -> Self {
        EpisodeNumber(num)
    }

    pub fn value(&self) -> u8 {
        self.0
    }
}

impl std::fmt::Display for EpisodeNumber {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl From<u8> for EpisodeNumber {
    fn from(num: u8) -> Self {
        EpisodeNumber(num)
    }
}

impl Default for EpisodeNumber {
    fn default() -> Self {
        EpisodeNumber(1) // Episode 1 is a reasonable default
    }
}

/// Movie endpoint URL with validation
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct MovieURL(String);

impl MovieURL {
    pub fn new(url: Url) -> Self {
        MovieURL(url.to_string())
    }

    pub fn from_string(s: String) -> Self {
        MovieURL(s)
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl std::fmt::Display for MovieURL {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl From<String> for MovieURL {
    fn from(s: String) -> Self {
        MovieURL(s)
    }
}

impl AsRef<str> for MovieURL {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

impl std::hash::Hash for MovieURL {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.0.hash(state);
    }
}

/// Series endpoint URL with validation
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct SeriesURL(String);

impl SeriesURL {
    pub fn new(url: Url) -> Self {
        SeriesURL(url.to_string())
    }

    pub fn from_string(s: String) -> Self {
        SeriesURL(s)
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl std::fmt::Display for SeriesURL {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl From<String> for SeriesURL {
    fn from(s: String) -> Self {
        SeriesURL(s)
    }
}

impl AsRef<str> for SeriesURL {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

impl std::hash::Hash for SeriesURL {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.0.hash(state);
    }
}

/// Season endpoint URL with validation
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct SeasonURL(String);

impl SeasonURL {
    pub fn new(url: Url) -> Self {
        SeasonURL(url.to_string())
    }

    pub fn from_string(s: String) -> Self {
        SeasonURL(s)
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl std::fmt::Display for SeasonURL {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl From<String> for SeasonURL {
    fn from(s: String) -> Self {
        SeasonURL(s)
    }
}

impl AsRef<str> for SeasonURL {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

impl std::hash::Hash for SeasonURL {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.0.hash(state);
    }
}

/// Episode endpoint URL with validation
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct EpisodeURL(String);

impl EpisodeURL {
    pub fn new(url: Url) -> Self {
        EpisodeURL(url.to_string())
    }

    pub fn from_string(s: String) -> Self {
        EpisodeURL(s)
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl std::fmt::Display for EpisodeURL {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl From<String> for EpisodeURL {
    fn from(s: String) -> Self {
        EpisodeURL(s)
    }
}

impl AsRef<str> for EpisodeURL {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

impl std::hash::Hash for EpisodeURL {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.0.hash(state);
    }
}

/// Lightweight movie reference for lists/collections
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MediaReference {
    Movie(MovieReference),
    Series(SeriesReference),
    Season(SeasonReference),
    Episode(EpisodeReference),
}

// ===== MediaReference Helper Methods =====

impl MediaReference {
    /// Get as a trait object for ergonomic method access
    pub fn as_ref(&self) -> &dyn MediaRef {
        match self {
            Self::Movie(m) => m,
            Self::Series(s) => s,
            Self::Season(s) => s,
            Self::Episode(e) => e,
        }
    }
    
    /// Get as a mutable trait object
    pub fn as_mut(&mut self) -> &mut dyn MediaRef {
        match self {
            Self::Movie(m) => m,
            Self::Series(s) => s,
            Self::Season(s) => s,
            Self::Episode(e) => e,
        }
    }
    
    /// Try to get as a specific movie reference
    pub fn as_movie(&self) -> Option<&MovieReference> {
        match self {
            Self::Movie(m) => Some(m),
            _ => None,
        }
    }
    
    /// Try to get as a specific series reference
    pub fn as_series(&self) -> Option<&SeriesReference> {
        match self {
            Self::Series(s) => Some(s),
            _ => None,
        }
    }
    
    /// Try to get as a specific season reference
    pub fn as_season(&self) -> Option<&SeasonReference> {
        match self {
            Self::Season(s) => Some(s),
            _ => None,
        }
    }
    
    /// Try to get as a specific episode reference
    pub fn as_episode(&self) -> Option<&EpisodeReference> {
        match self {
            Self::Episode(e) => Some(e),
            _ => None,
        }
    }
    
    /// Get as a playable item if this media can be played
    pub fn as_playable(&self) -> Option<&dyn Playable> {
        match self {
            Self::Movie(m) => Some(m),
            Self::Episode(e) => Some(e),
            _ => None, // Series and seasons can't be played directly
        }
    }
    
    /// Get as a browsable item if this media contains other media
    pub fn as_browsable(&self) -> Option<&dyn Browsable> {
        match self {
            Self::Series(s) => Some(s),
            Self::Season(s) => Some(s),
            _ => None, // Movies and episodes don't contain other media
        }
    }
    
    /// Helper to get media type
    pub fn media_type(&self) -> &'static str {
        match self {
            Self::Movie(_) => "movie",
            Self::Series(_) => "series",
            Self::Season(_) => "season",
            Self::Episode(_) => "episode",
        }
    }
}

/// Lightweight movie reference for lists/collections
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct MovieReference {
    pub id: MovieID,
    pub tmdb_id: u64,
    pub title: MovieTitle,
    pub details: MediaDetailsOption,
    pub endpoint: MovieURL,
    pub file: MediaFile,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub theme_color: Option<String>, // Hex color e.g. "#2C3E50"
}

/// Lightweight series reference for lists/collections
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct SeriesReference {
    pub id: SeriesID,
    pub library_id: Uuid,
    pub tmdb_id: u64,
    pub title: SeriesTitle,
    pub details: MediaDetailsOption,
    pub endpoint: SeriesURL,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub theme_color: Option<String>, // Hex color e.g. "#2C3E50"
}

/// Lightweight season reference
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct SeasonReference {
    pub id: SeasonID,
    pub season_number: SeasonNumber,
    pub series_id: SeriesID, // Link to parent series
    pub tmdb_series_id: u64,
    pub details: MediaDetailsOption,
    pub endpoint: SeasonURL,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub theme_color: Option<String>, // Hex color e.g. "#2C3E50"
}

/// Lightweight episode reference
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct EpisodeReference {
    pub id: EpisodeID,
    pub episode_number: EpisodeNumber,
    pub season_number: SeasonNumber,
    pub season_id: SeasonID, // Link to parent season
    pub series_id: SeriesID, // Link to parent series
    pub tmdb_series_id: u64,
    pub details: MediaDetailsOption,
    pub endpoint: EpisodeURL,
    pub file: MediaFile,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MediaDetailsOption {
    Endpoint(String),
    Details(TmdbDetails),
}

impl MediaDetailsOption {
    /// Extract release year from movie details if available
    pub fn get_release_year(&self) -> Option<u16> {
        match self {
            MediaDetailsOption::Endpoint(_) => None,
            MediaDetailsOption::Details(details) => match details {
                TmdbDetails::Movie(movie) => movie
                    .release_date
                    .as_ref()
                    .and_then(|date| date.split('-').next())
                    .and_then(|year| year.parse().ok()),
                _ => None,
            },
        }
    }
}

// ===== MediaRef Trait System =====
// 
// This trait system provides a clean interface for working with media references
// without the need for repetitive pattern matching. It maintains backward compatibility
// while offering better ergonomics for common operations.

/// Common interface for all media reference types
pub trait MediaRef: Send + Sync {
    /// Get the unique media ID
    fn id(&self) -> MediaId;
    
    /// Get the display title
    fn title(&self) -> &str;
    
    /// Get media details if available
    fn details(&self) -> &MediaDetailsOption;
    
    /// Get theme color if available
    fn theme_color(&self) -> Option<&str>;
    
    /// Get the API endpoint
    fn endpoint(&self) -> String;
    
    /// Get release/air year if available
    fn year(&self) -> Option<u16> {
        match self.details() {
            MediaDetailsOption::Details(details) => match details {
                TmdbDetails::Movie(movie) => movie.release_date
                    .as_ref()
                    .and_then(|date| date.split('-').next())
                    .and_then(|year| year.parse().ok()),
                TmdbDetails::Series(series) => series.first_air_date
                    .as_ref()
                    .and_then(|date| date.split('-').next())
                    .and_then(|year| year.parse().ok()),
                TmdbDetails::Season(season) => season.air_date
                    .as_ref()
                    .and_then(|date| date.split('-').next())
                    .and_then(|year| year.parse().ok()),
                TmdbDetails::Episode(episode) => episode.air_date
                    .as_ref()
                    .and_then(|date| date.split('-').next())
                    .and_then(|year| year.parse().ok()),
            },
            _ => None,
        }
    }
    
    /// Get rating if available
    fn rating(&self) -> Option<f32> {
        match self.details() {
            MediaDetailsOption::Details(details) => match details {
                TmdbDetails::Movie(movie) => movie.vote_average,
                TmdbDetails::Series(series) => series.vote_average,
                TmdbDetails::Episode(episode) => episode.vote_average,
                TmdbDetails::Season(_) => None, // Seasons don't have ratings
            },
            _ => None,
        }
    }
    
    /// Get genres if available
    fn genres(&self) -> Vec<&str> {
        match self.details() {
            MediaDetailsOption::Details(details) => match details {
                TmdbDetails::Movie(movie) => movie.genres.iter().map(|s| s.as_str()).collect(),
                TmdbDetails::Series(series) => series.genres.iter().map(|s| s.as_str()).collect(),
                _ => Vec::new(), // Episodes and seasons don't have their own genres
            },
            _ => Vec::new(),
        }
    }
}

/// Specialized trait for media that can be played
pub trait Playable: MediaRef {
    /// Get the media file
    fn file(&self) -> &MediaFile;
    
    /// Get duration if available from metadata
    fn duration(&self) -> Option<Duration> {
        self.file()
            .media_file_metadata
            .as_ref()
            .and_then(|meta| meta.duration)
            .map(|secs| Duration::from_secs_f64(secs))
    }
    
    /// Check if the media can be transcoded
    fn can_transcode(&self) -> bool {
        // Default implementation - can be overridden
        self.file().media_file_metadata.is_some()
    }
}

/// Specialized trait for media that contains other media
pub trait Browsable: MediaRef {
    /// Get the number of child items if known
    fn child_count(&self) -> Option<usize>;
    
    /// Get the library ID this media belongs to
    fn library_id(&self) -> Uuid;
}

// ===== MediaRef Implementations =====

impl MediaRef for MovieReference {
    fn id(&self) -> MediaId {
        MediaId::Movie(self.id.clone())
    }
    
    fn title(&self) -> &str {
        self.title.as_str()
    }
    
    fn details(&self) -> &MediaDetailsOption {
        &self.details
    }
    
    fn theme_color(&self) -> Option<&str> {
        self.theme_color.as_deref()
    }
    
    fn endpoint(&self) -> String {
        self.endpoint.as_str().to_string()
    }
}

impl MediaRef for SeriesReference {
    fn id(&self) -> MediaId {
        MediaId::Series(self.id.clone())
    }
    
    fn title(&self) -> &str {
        self.title.as_str()
    }
    
    fn details(&self) -> &MediaDetailsOption {
        &self.details
    }
    
    fn theme_color(&self) -> Option<&str> {
        self.theme_color.as_deref()
    }
    
    fn endpoint(&self) -> String {
        self.endpoint.as_str().to_string()
    }
}

impl MediaRef for SeasonReference {
    fn id(&self) -> MediaId {
        MediaId::Season(self.id.clone())
    }
    
    fn title(&self) -> &str {
        // For seasons, extract the name from details if available
        match &self.details {
            MediaDetailsOption::Details(TmdbDetails::Season(details)) => &details.name,
            _ => "Unknown Season",
        }
    }
    
    fn details(&self) -> &MediaDetailsOption {
        &self.details
    }
    
    fn theme_color(&self) -> Option<&str> {
        self.theme_color.as_deref()
    }
    
    fn endpoint(&self) -> String {
        self.endpoint.as_str().to_string()
    }
}

impl MediaRef for EpisodeReference {
    fn id(&self) -> MediaId {
        MediaId::Episode(self.id.clone())
    }
    
    fn title(&self) -> &str {
        // For episodes, extract the name from details if available
        match &self.details {
            MediaDetailsOption::Details(TmdbDetails::Episode(details)) => &details.name,
            _ => "Unknown Episode",
        }
    }
    
    fn details(&self) -> &MediaDetailsOption {
        &self.details
    }
    
    fn theme_color(&self) -> Option<&str> {
        None // Episodes don't have theme colors in the current schema
    }
    
    fn endpoint(&self) -> String {
        self.endpoint.as_str().to_string()
    }
}

// ===== Playable Implementations =====

impl Playable for MovieReference {
    fn file(&self) -> &MediaFile {
        &self.file
    }
}

impl Playable for EpisodeReference {
    fn file(&self) -> &MediaFile {
        &self.file
    }
}

// ===== Browsable Implementations =====

impl Browsable for SeriesReference {
    fn child_count(&self) -> Option<usize> {
        match &self.details {
            MediaDetailsOption::Details(TmdbDetails::Series(details)) => {
                details.number_of_episodes.map(|n| n as usize)
            }
            _ => None,
        }
    }
    
    fn library_id(&self) -> Uuid {
        self.library_id
    }
}

impl Browsable for SeasonReference {
    fn child_count(&self) -> Option<usize> {
        match &self.details {
            MediaDetailsOption::Details(TmdbDetails::Season(details)) => {
                Some(details.episode_count as usize)
            }
            _ => None,
        }
    }
    
    fn library_id(&self) -> Uuid {
        // Seasons don't store library_id directly, would need to be fetched from parent series
        // For now, return a nil UUID - this should be addressed in a future refactor
        Uuid::nil()
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TmdbDetails {
    Movie(EnhancedMovieDetails),
    Series(EnhancedSeriesDetails),
    Season(SeasonDetails),
    Episode(EpisodeDetails),
}

/// Enhanced metadata that includes images, credits, and additional information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnhancedMovieDetails {
    // Basic details
    pub id: u64,
    pub title: String,
    pub overview: Option<String>,
    pub release_date: Option<String>,
    pub runtime: Option<u32>,
    pub vote_average: Option<f32>,
    pub vote_count: Option<u32>,
    pub popularity: Option<f32>,
    pub genres: Vec<String>,
    pub production_companies: Vec<String>,

    // Media assets
    pub poster_path: Option<String>,
    pub backdrop_path: Option<String>,
    pub logo_path: Option<String>,
    pub images: MediaImages,

    // Credits
    pub cast: Vec<CastMember>,
    pub crew: Vec<CrewMember>,

    // Additional
    pub videos: Vec<Video>,
    pub keywords: Vec<String>,
    pub external_ids: ExternalIds,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnhancedSeriesDetails {
    // Basic details
    pub id: u64,
    pub name: String,
    pub overview: Option<String>,
    pub first_air_date: Option<String>,
    pub last_air_date: Option<String>,
    pub number_of_seasons: Option<u32>,
    pub number_of_episodes: Option<u32>,
    pub vote_average: Option<f32>,
    pub vote_count: Option<u32>,
    pub popularity: Option<f32>,
    pub genres: Vec<String>,
    pub networks: Vec<String>,

    // Media assets
    pub poster_path: Option<String>,
    pub backdrop_path: Option<String>,
    pub logo_path: Option<String>,
    pub images: MediaImages,

    // Credits
    pub cast: Vec<CastMember>,
    pub crew: Vec<CrewMember>,

    // Additional
    pub videos: Vec<Video>,
    pub keywords: Vec<String>,
    pub external_ids: ExternalIds,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SeasonDetails {
    pub id: u64,
    pub season_number: u8,
    pub name: String,
    pub overview: Option<String>,
    pub air_date: Option<String>,
    pub episode_count: u32,
    pub poster_path: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EpisodeDetails {
    pub id: u64,
    pub episode_number: u8,
    pub season_number: u8,
    pub name: String,
    pub overview: Option<String>,
    pub air_date: Option<String>,
    pub runtime: Option<u32>,
    pub still_path: Option<String>,
    pub vote_average: Option<f32>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImageMetadata {
    pub file_path: String,
    pub width: u64,
    pub height: u64,
    pub aspect_ratio: f64,
    pub iso_639_1: Option<String>,
    pub vote_average: f64,
    pub vote_count: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImageWithMetadata {
    pub endpoint: String,
    pub metadata: ImageMetadata,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct MediaImages {
    pub posters: Vec<ImageWithMetadata>,
    pub backdrops: Vec<ImageWithMetadata>,
    pub logos: Vec<ImageWithMetadata>,
    pub stills: Vec<ImageWithMetadata>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CastMember {
    pub id: u64,
    pub name: String,
    pub character: String,
    pub profile_path: Option<String>,
    pub order: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CrewMember {
    pub id: u64,
    pub name: String,
    pub job: String,
    pub department: String,
    pub profile_path: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Video {
    pub key: String,
    pub name: String,
    pub site: String,
    pub video_type: String,
    pub official: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ExternalIds {
    pub imdb_id: Option<String>,
    pub tvdb_id: Option<u32>,
    pub facebook_id: Option<String>,
    pub instagram_id: Option<String>,
    pub twitter_id: Option<String>,
}

// Media enum removed - duplicate of definition in tmdb_api_provider.rs

// Library reference type - no media references
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LibraryReference {
    pub id: Uuid,
    pub name: String,
    pub library_type: crate::LibraryType,
    pub paths: Vec<PathBuf>,
}
