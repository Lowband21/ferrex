use crate::{
    DedupeKey, EpisodeID, JobId, JobPriority, LibraryID, LibraryRootsId, LibraryType, MovieID,
    Result, ScanReason, SeasonID, SeriesID,
};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

use super::folder::FolderScanContext;
use super::library::MaintenancePartition;

/// Classification hint for discovered media files during a folder scan.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum MediaKindHint {
    Movie,
    Episode,
    Extra,
    Unknown,
}

impl MediaKindHint {
    pub fn as_str(&self) -> &'static str {
        match self {
            MediaKindHint::Movie => "Movie",
            MediaKindHint::Episode => "Episode",
            MediaKindHint::Extra => "Extra",
            MediaKindHint::Unknown => "Unknown",
        }
    }
}

/// Event emitted by `FolderScanActor` when it finds a media file.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct MediaFileDiscovered {
    pub library_id: LibraryID,
    pub path_norm: String,
    pub fingerprint: crate::orchestration::job::MediaFingerprint,
    pub classified_as: MediaKindHint,
    pub context: FolderScanContext,
}

/// Request from a library actor to seed scans for a batch of folders.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SeedFoldersRequest {
    pub library_id: LibraryID,
    pub folders: Vec<SeededFolder>,
    pub mode: SeedMode,
    pub requested_at: DateTime<Utc>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum SeedMode {
    Startup,
    BulkInitialization,
    Maintenance,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SeededFolder {
    pub path_norm: String,
    pub priority: JobPriority,
    pub reason: ScanReason,
}

/// Maintenance scheduling plan generated by the library actor.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct MaintenanceBatch {
    pub library_id: LibraryID,
    pub partition: MaintenancePartition,
    pub folders: Vec<String>,
    pub issued_at: DateTime<Utc>,
}

/// Track idempotency tokens for folders that have already been enqueued.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct IssuedJobRecord {
    pub dedupe_key: DedupeKey,
    pub job_id: Option<JobId>,
    pub issued_at: DateTime<Utc>,
    pub pending_children: Vec<String>,
}

/// Response carrying a maintenance queue cursor per partition.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct MaintenanceSnapshot {
    pub partitions: HashMap<LibraryRootsId, (MaintenancePartition, DateTime<Utc>)>,
}

/// Hook for pluggable observers (metrics/tracing) to receive actor lifecycle events.
pub trait ActorObserver: Send + Sync {
    fn on_media_discovered(&self, _event: &MediaFileDiscovered) -> Result<()> {
        Ok(())
    }

    fn on_seed_batch(&self, _seed: &SeedFoldersRequest) -> Result<()> {
        Ok(())
    }

    fn on_maintenance_batch(&self, _batch: &MaintenanceBatch) -> Result<()> {
        Ok(())
    }
}

pub struct NoopActorObserver;

impl ActorObserver for NoopActorObserver {}

/// Outcome summary produced by `FolderScanActor` for diagnostics.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct FolderScanSummary {
    pub context: FolderScanContext,
    pub discovered_files: usize,
    pub enqueued_subfolders: usize,
    pub listing_hash: String,
    pub completed_at: DateTime<Utc>,
}

/// Identifies parent hierarchy for folder scans, enabling heuristic classification.
#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub struct ParentDescriptors {
    pub series_id: Option<SeriesID>,
    pub season_id: Option<SeasonID>,
    pub movie_id: Option<MovieID>,
    pub episode_id: Option<EpisodeID>,
    pub resolved_type: Option<LibraryType>,
    pub extra_tag: Option<String>,
}
