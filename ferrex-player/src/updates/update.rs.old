use std::sync::Arc;
use std::time::{Duration, Instant};

use iced::{widget::scrollable, Task};

use crate::{
    api_types::MediaReference,
    media_library::{self},
    message::Message,
    player::{
        video::{close_video, load_video},
        PlayerMessage,
    },
    profiling::PROFILER,
    state::{State, ViewMode, ViewState},
    updates::{
        clear_database::{handle_clear_database, handle_database_cleared},
        library_loaded::{handle_libraries_loaded, handle_load_libraries},
        library_management::{
            handle_create_library, handle_delete_library, handle_hide_library_form,
            handle_library_created, handle_library_deleted, handle_library_updated,
            handle_show_library_form, handle_submit_library_form,
            handle_toggle_library_form_enabled, handle_update_libarary_form_name,
            handle_update_library, handle_update_library_form_paths,
            handle_update_library_form_scan_interval, handle_update_library_form_type,
        },
        media_events::{handle_media_event_received, handle_media_events_error},
        navigation_updates::{handle_view_episode, handle_view_season, handle_view_tv_show},
        play_media::{handle_media_unavailable, handle_play_media},
        refresh_library::handle_refresh_library,
        scan_updates::{
            handle_active_scans_checked, handle_clear_scan_progress, handle_force_rescan,
            handle_scan_all_libraries, handle_scan_library, handle_scan_progress_update,
            handle_scan_started, handle_toggle_scan_progress,
        },
        scroll_updates::{handle_movies_grid_scrolled, handle_tv_shows_grid_scrolled},
        select_library::handle_select_library,
        set_view_mode::handle_set_view_mode,
        transcoding::{
            handle_check_transcoding_status, handle_transcoding_started,
            handle_transcoding_status_update,
        },
        tv_details::{handle_season_loaded, handle_tv_show_loaded},
        window_update::handle_window_resized,
    },
    view_models::ViewModel,
    views::carousel::CarouselMessage,
};
use ferrex_core::MediaId;

// Lower SCROLL_STOP_DEBOUNCE_MS for quicker poster loading after scroll
// Higher values reduce unnecessary loads during small scroll adjustments
const SCROLL_STOP_DEBOUNCE_MS: u64 = 10; // milliseconds to wait before considering scroll stopped

// Monitor ui_performance.log for frame times exceeding 16ms during scrolling
// Adjust thresholds if you see consistent patterns of slow frames

/// Handle a batch of media details updates efficiently
fn handle_media_details_batch(state: &mut State, batch: Vec<MediaReference>) -> Task<Message> {
    state.handle_media_details_batch(batch)
}

pub fn update(state: &mut State, message: Message) -> Task<Message> {
    let message_name = message.name();
    PROFILER.start(&format!("update::{}", message_name));

    let result = match message {
        Message::RefreshLibrary => handle_refresh_library(state),

        // Library Management Messages
        Message::LibrariesLoaded(result) => handle_libraries_loaded(state, result),

        Message::LoadLibraries => handle_load_libraries(state),

        Message::CreateLibrary(library) => handle_create_library(state, library),

        Message::LibraryCreated(result) => handle_library_created(state, result),

        Message::UpdateLibrary(library) => handle_update_library(state, library),

        Message::LibraryUpdated(result) => handle_library_updated(state, result),

        Message::DeleteLibrary(library_id) => handle_delete_library(state, library_id),

        Message::LibraryDeleted(result) => handle_library_deleted(state, result),

        Message::SelectLibrary(library_id) => handle_select_library(state, library_id),

        Message::LibrarySelected(_library_id, _result) => {
            // Legacy handler removed - using reference-based API
            Task::none()
        }

        Message::ScanLibrary_(library_id) => handle_scan_library(state, library_id),

        Message::ShowLibraryManagement => {
            // Handled by UI domain
            unreachable!("ShowLibraryManagement should be handled by UI domain")
        }

        Message::HideLibraryManagement => {
            // Handled by UI domain
            unreachable!("HideLibraryManagement should be handled by UI domain")
        }

        Message::ShowAdminDashboard => {
            // Handled by UI domain
            unreachable!("ShowAdminDashboard should be handled by UI domain")
        }

        Message::HideAdminDashboard => {
            // Handled by UI domain
            unreachable!("HideAdminDashboard should be handled by UI domain")
        }

        Message::ShowClearDatabaseConfirm => {
            // Handled by UI domain
            unreachable!("ShowClearDatabaseConfirm should be handled by UI domain")
        }

        Message::HideClearDatabaseConfirm => {
            // Handled by UI domain
            unreachable!("HideClearDatabaseConfirm should be handled by UI domain")
        }

        Message::ClearDatabase => {
            // Handled by UI domain
            unreachable!("ClearDatabase should be handled by UI domain")
        }

        Message::DatabaseCleared(_result) => {
            // Handled by UI domain
            unreachable!("DatabaseCleared should be handled by UI domain")
        }

        Message::ShowMetadataRefreshed(show_name) => {
            log::info!("TV show metadata refreshed for: {}", show_name);

            // Image loading handled by UnifiedImageService
            Task::none()
        }

        Message::ShowMetadataRefreshFailed(show_name, error) => {
            log::error!(
                "Failed to refresh TV show metadata for '{}': {}",
                show_name,
                error
            );
            // Image loading handled by UnifiedImageService
            Task::none()
        }

        // Library form management
        Message::ShowLibraryForm(library) => handle_show_library_form(state, library),

        Message::HideLibraryForm => handle_hide_library_form(state),

        Message::UpdateLibraryFormName(name) => handle_update_libarary_form_name(state, name),

        Message::UpdateLibraryFormType(library_type) => {
            handle_update_library_form_type(state, library_type)
        }

        Message::UpdateLibraryFormPaths(paths) => handle_update_library_form_paths(state, paths),

        Message::UpdateLibraryFormScanInterval(interval) => {
            handle_update_library_form_scan_interval(state, interval)
        }

        Message::ToggleLibraryFormEnabled => handle_toggle_library_form_enabled(state),

        Message::SubmitLibraryForm => handle_submit_library_form(state),

        Message::ScanLibrary => handle_scan_all_libraries(state),

        Message::ForceRescan => handle_force_rescan(state),

        Message::ScanStarted(result) => handle_scan_started(state, result),

        Message::ScanProgressUpdate(progress) => handle_scan_progress_update(state, progress),

        Message::ClearScanProgress => handle_clear_scan_progress(state),

        Message::ToggleScanProgress => handle_toggle_scan_progress(state),

        Message::ActiveScansChecked(scans) => handle_active_scans_checked(state, scans),


        Message::MediaOrganized(movies, tv_shows) => {
            super::media_organization::handle_media_organized(state, movies, tv_shows)
        }

        Message::MoviesGridScrolled(viewport) => handle_movies_grid_scrolled(state, viewport),

        Message::TvShowsGridScrolled(viewport) => handle_tv_shows_grid_scrolled(state, viewport),

        Message::DetailViewScrolled(viewport) => {
            // Update scroll offset for fixed backdrop
            state.background_shader_state.scroll_offset = viewport.absolute_offset().y;

            // Update depth lines to move with the scrolled content
            state.background_shader_state.update_depth_lines(
                &state.view,
                state.window_size.width,
                state.window_size.height,
            );

            Task::none()
        }

        Message::UpdateTransitions => {
            // Update all active transitions
            state.background_shader_state.color_transitions.update();
            state.background_shader_state.backdrop_transitions.update();
            state.background_shader_state.gradient_transitions.update();

            // Update the actual colors based on transition progress
            let (primary, secondary) = state
                .background_shader_state
                .color_transitions
                .get_interpolated_colors();
            state.background_shader_state.primary_color = primary;
            state.background_shader_state.secondary_color = secondary;

            // Update the gradient center based on transition progress
            state.background_shader_state.gradient_center = state
                .background_shader_state
                .gradient_transitions
                .get_interpolated_center();

            Task::none()
        }

        Message::ScanCompleted(result) => {
            state.scanning = false;
            match result {
                Ok(msg) => {
                    log::info!("Scan completed: {}", msg);
                    // Refresh library after successful scan
                    update(state, Message::RefreshLibrary)
                }
                Err(e) => {
                    log::error!("Scan failed: {}", e);
                    state.error_message = Some(format!("Scan failed: {}", e));
                    Task::none()
                }
            }
        }

        Message::PlayMedia(media) => {
            // Clear MediaId since this is the old-style PlayMedia without ID
            state.player.current_media_id = None;
            handle_play_media(state, media)
        }

        Message::PlayMediaWithId(media, media_id) => {
            // Store the MediaId for watch status tracking
            state.player.current_media_id = Some(media_id);
            handle_play_media(state, media)
        }

        Message::MediaUnavailable(reason, message) => {
            handle_media_unavailable(state, reason, message)
        }

        Message::ViewDetails(media) => super::navigation_updates::handle_view_details(state, media),

        Message::ViewMovieDetails(movie) => {
            super::navigation_updates::handle_view_movie_details(state, movie)
        }

        Message::ViewTvShow(series_id) => handle_view_tv_show(state, series_id),

        Message::ViewSeason(series_id, season_id) => {
            handle_view_season(state, series_id, season_id)
        }

        Message::ViewEpisode(episode_id) => handle_view_episode(state, episode_id),

        Message::SetViewMode(mode) => handle_set_view_mode(state, mode),

        Message::SetSortBy(sort_by) => {
            super::media_organization::handle_set_sort_by(state, sort_by)
        }

        Message::ToggleSortOrder => super::media_organization::handle_toggle_sort_order(state),

        Message::TvShowLoaded(show_name, result) => handle_tv_show_loaded(state, show_name, result),

        Message::SeasonLoaded(show_name, season_num, result) => {
            handle_season_loaded(state, show_name, season_num, result)
        }

        // Delegate player messages to the player module
        msg if PlayerMessage::is_player_message(&msg) => {
            if let Some(player_msg) = PlayerMessage::from_main_message(msg) {
                // Handle special cases that need access to main state
                match &player_msg {
                    PlayerMessage::BackToLibrary => {
                        // Send final progress update before closing
                        let mut final_update_task = Task::none();
                        let mut restore_task = Task::none(); // Initialize restore_task at proper scope

                        if let (Some(api_client), Some(media)) =
                            (&state.api_client, &state.player.current_media)
                        {
                            if state.player.position > 0.0 {
                                let api_client = api_client.clone();
                                // Use the stored MediaId from when PlayMediaWithId was called
                                let media_id = match state.player.current_media_id.clone() {
                                    Some(id) => id,
                                    None => {
                                        log::error!("No MediaId stored for current media");
                                        return Task::batch(vec![Task::none(), restore_task]);
                                    }
                                };

                                let position = state.player.position as f32;
                                let duration = state.player.duration as f32;

                                log::debug!("Sending final watch progress before returning to library: position={:.1}s", position);

                                final_update_task = Task::perform(
                                    async move {
                                        let request =
                                            ferrex_core::watch_status::UpdateProgressRequest {
                                                media_id,
                                                position,
                                                duration,
                                            };
                                        match api_client.update_watch_progress(&request).await {
                                            Ok(_) => log::debug!(
                                                "Final watch progress sent: position={:.1}s",
                                                position
                                            ),
                                            Err(e) => log::error!(
                                                "Failed to send final watch progress: {}",
                                                e
                                            ),
                                        }
                                    },
                                    |_| Message::NoOp,
                                );
                            }
                        }

                        close_video(state);
                        state.view = ViewState::Library;

                        // Clear detail view data
                        state.current_show_seasons.clear();
                        state.current_season_episodes.clear();

                        // Transition back to default colors
                        use crate::theme::MediaServerTheme;
                        use crate::widgets::BackgroundEffect;

                        // Transition colors back to defaults
                        state
                            .background_shader_state
                            .color_transitions
                            .transition_to(
                                MediaServerTheme::SOFT_GREY_DARK,
                                MediaServerTheme::SOFT_GREY_LIGHT,
                            );

                        // Animate gradient center to new position
                        let new_center = crate::transitions::generate_random_gradient_center();
                        state
                            .background_shader_state
                            .gradient_transitions
                            .transition_to(new_center);

                        // Clear backdrop with fade out
                        if state.background_shader_state.backdrop_handle.is_some() {
                            // Start fade out animation
                            state
                                .background_shader_state
                                .backdrop_transitions
                                .opacity
                                .transition_to(0.0);
                        }

                        state.background_shader_state.backdrop_handle = None;
                        state.background_shader_state.backdrop_aspect_ratio = None;
                        state.background_shader_state.effect = BackgroundEffect::Gradient;
                        state.background_shader_state.scroll_offset = 0.0;

                        log::info!("Running update depth lines");
                        // Update depth regions for library view
                        state.background_shader_state.update_depth_lines(
                            &state.view,
                            state.window_size.width,
                            state.window_size.height,
                        );

                        // Restore scroll position when returning to library
                        restore_task = Task::none();
                        match state.view_mode {
                            ViewMode::Movies => {
                                if let Some(position) = state.movies_scroll_position {
                                    log::debug!("Restoring movies scroll position: {}", position);
                                    restore_task = scrollable::scroll_to(
                                        state.movies_view_model.grid_state().scrollable_id.clone(),
                                        scrollable::AbsoluteOffset {
                                            x: 0.0,
                                            y: position,
                                        },
                                    );
                                }
                            }
                            ViewMode::TvShows => {
                                if let Some(position) = state.tv_shows_scroll_position {
                                    log::debug!("Restoring TV shows scroll position: {}", position);
                                    restore_task = scrollable::scroll_to(
                                        state.tv_view_model.grid_state().scrollable_id.clone(),
                                        scrollable::AbsoluteOffset {
                                            x: 0.0,
                                            y: position,
                                        },
                                    );
                                }
                            }
                            ViewMode::All => {
                                // In All mode, could restore both but let's just restore movies for simplicity
                                if let Some(position) = state.movies_scroll_position {
                                    restore_task = scrollable::scroll_to(
                                        state.movies_view_model.grid_state().scrollable_id.clone(),
                                        scrollable::AbsoluteOffset {
                                            x: 0.0,
                                            y: position,
                                        },
                                    );
                                }
                            }
                        }

                        // Combine final update task with restore task
                        return Task::batch(vec![final_update_task, restore_task]);
                    }
                    PlayerMessage::Stop => {
                        // Send final progress update before stopping
                        let mut final_update_task = Task::none();
                        let mut restore_task = Task::none(); // Initialize restore_task at proper scope

                        if let (Some(api_client), Some(media)) =
                            (&state.api_client, &state.player.current_media)
                        {
                            if state.player.position > 0.0 {
                                let api_client = api_client.clone();
                                // Use the stored MediaId from when PlayMediaWithId was called
                                let media_id = match state.player.current_media_id.clone() {
                                    Some(id) => id,
                                    None => {
                                        log::error!("No MediaId stored for current media");
                                        return Task::batch(vec![Task::none(), restore_task]);
                                    }
                                };
                                let position = state.player.position as f32;
                                let duration = state.player.duration as f32;

                                log::debug!(
                                    "Sending final watch progress before stopping: position={:.1}s",
                                    position
                                );

                                final_update_task = Task::perform(
                                    async move {
                                        let request =
                                            ferrex_core::watch_status::UpdateProgressRequest {
                                                media_id,
                                                position,
                                                duration,
                                            };
                                        match api_client.update_watch_progress(&request).await {
                                            Ok(_) => log::debug!(
                                                "Final watch progress sent: position={:.1}s",
                                                position
                                            ),
                                            Err(e) => log::error!(
                                                "Failed to send final watch progress: {}",
                                                e
                                            ),
                                        }
                                    },
                                    |_| Message::NoOp,
                                );
                            }
                        }

                        // Stop playback and return to library
                        close_video(state);
                        state.view = ViewState::Library;

                        // Restore scroll position when returning to library
                        restore_task = Task::none();
                        match state.view_mode {
                            ViewMode::Movies => {
                                if let Some(position) = state.movies_scroll_position {
                                    log::debug!(
                                        "Restoring movies scroll position after stop: {}",
                                        position
                                    );
                                    restore_task = scrollable::scroll_to(
                                        state.movies_view_model.grid_state().scrollable_id.clone(),
                                        scrollable::AbsoluteOffset {
                                            x: 0.0,
                                            y: position,
                                        },
                                    );
                                }
                            }
                            ViewMode::TvShows => {
                                if let Some(position) = state.tv_shows_scroll_position {
                                    log::debug!(
                                        "Restoring TV shows scroll position after stop: {}",
                                        position
                                    );
                                    restore_task = scrollable::scroll_to(
                                        state.tv_view_model.grid_state().scrollable_id.clone(),
                                        scrollable::AbsoluteOffset {
                                            x: 0.0,
                                            y: position,
                                        },
                                    );
                                }
                            }
                            ViewMode::All => {
                                // In All mode, could restore both but let's just restore movies for simplicity
                                if let Some(position) = state.movies_scroll_position {
                                    restore_task = scrollable::scroll_to(
                                        state.movies_view_model.grid_state().scrollable_id.clone(),
                                        scrollable::AbsoluteOffset {
                                            x: 0.0,
                                            y: position,
                                        },
                                    );
                                }
                            }
                        }

                        // Combine final update task with restore task
                        return Task::batch(vec![final_update_task, restore_task]);
                    }
                    PlayerMessage::Reload => {
                        return load_video(state);
                    }
                    _ => {}
                }

                // Delegate to player module
                let task = state.player.update(player_msg);

                // Update controls tracking if needed
                if state.player.controls
                    && state.player.controls_time.elapsed() > Duration::from_secs(3)
                {
                    state.player.controls = false;
                }

                task
            } else {
                Task::none()
            }
        }

        Message::Tick => {
            // Check if controls should be hidden
            if state.player.controls
                && state.player.controls_time.elapsed() > Duration::from_secs(3)
            {
                state.player.controls = false;
            }

            // Handle pending seeks (for throttled seeking)
            if state.player.dragging && state.player.pending_seek_position.is_some() {
                if let Some(pending_position) = state.player.pending_seek_position {
                    let should_seek = match state.player.last_seek_time {
                        Some(last_time) => last_time.elapsed() > Duration::from_millis(100),
                        None => true,
                    };

                    if should_seek {
                        if let Some(video) = &mut state.player.video_opt {
                            let duration =
                                Duration::try_from_secs_f64(pending_position).unwrap_or_default();
                            if let Err(e) = video.seek(duration, false) {
                                log::error!("Pending seek failed: {:?}", e);
                            } else {
                                state.player.last_seek_time = Some(Instant::now());
                                state.player.pending_seek_position = None;
                            }
                        }
                    }
                }
            }

            // Clear seeking flag if we're able to get position again
            if state.player.seeking {
                if let Some(video) = &state.player.video_opt {
                    let pos = video.position().as_secs_f64();
                    if pos > 0.0 {
                        // We got a valid position, seek is complete
                        state.player.seeking = false;
                        state.player.position = pos;
                        log::debug!("Seek completed, position now: {}", pos);
                    }
                }
            }

            // Update position and duration from video if not dragging
            if let Some(video) = &state.player.video_opt {
                // For direct streams, always get duration from video object
                // For HLS, only update if we don't have duration yet
                if !state.player.using_hls || state.player.duration <= 0.0 {
                    let new_duration = video.duration().as_secs_f64();
                    if new_duration > 0.0
                        && (state.player.duration <= 0.0 || !state.player.using_hls)
                    {
                        if (new_duration - state.player.duration).abs() > 0.1 {
                            log::info!(
                                "Duration updated: {} -> {} seconds (using_hls: {})",
                                state.player.duration,
                                new_duration,
                                state.player.using_hls
                            );
                        }
                        state.player.duration = new_duration;

                        // Also update source_duration if not set
                        if state.player.source_duration.is_none() {
                            state.player.source_duration = Some(new_duration);
                        }
                    }
                }

                // Always update position when not dragging/seeking
                if !state.player.dragging && !state.player.seeking {
                    let new_position = video.position().as_secs_f64();

                    // Log position changes for debugging
                    if (new_position - state.player.position).abs() > 0.1 {
                        log::debug!(
                            "Position update: {:.1}s -> {:.1}s (duration: {:.1}s, using_hls: {})",
                            state.player.position,
                            new_position,
                            state.player.duration,
                            state.player.using_hls
                        );
                    }

                    // Update position for smooth seek bar movement
                    state.player.position = new_position;
                }
            }

            // Update track notification timeout
            state.player.update_track_notification();

            // Send periodic watch progress updates
            if let Some(video) = &state.player.video_opt {
                if !video.paused() && state.player.position > 0.0 {
                    // Check if we should send a progress update (every 10 seconds)
                    let should_update = if let Some(last_update) = state.player.last_progress_update
                    {
                        last_update.elapsed() >= std::time::Duration::from_secs(10)
                    } else {
                        true // First update
                    };

                    // Also check if position changed significantly (more than 5 seconds)
                    let position_changed =
                        (state.player.position - state.player.last_progress_sent).abs() > 5.0;

                    if should_update && position_changed {
                        if let (Some(api_client), Some(media)) =
                            (&state.api_client, &state.player.current_media)
                        {
                            let api_client = api_client.clone();
                            // Use the stored MediaId from when PlayMediaWithId was called
                            let media_id = match state.player.current_media_id.clone() {
                                Some(id) => id,
                                None => {
                                    log::error!("No MediaId stored for current media");
                                    return Task::none();
                                }
                            };
                            let position = state.player.position as f32;
                            let duration = state.player.duration as f32;

                            // Update tracking
                            state.player.last_progress_update = Some(std::time::Instant::now());
                            state.player.last_progress_sent = state.player.position;

                            // Update local watch state immediately
                            if let Some(ref mut watch_state) = state.user_watch_state {
                                // Check if it's already in progress
                                let progress_item_exists = watch_state
                                    .in_progress
                                    .iter_mut()
                                    .find(|item| item.media_id == media_id);

                                if let Some(item) = progress_item_exists {
                                    // Update existing progress
                                    item.position = position;
                                    if duration > 0.0 {
                                        item.duration = duration;
                                    }
                                    item.last_watched = chrono::Utc::now().timestamp();

                                    // Check if completed (>= 95%)
                                    if item.duration > 0.0 && item.position / item.duration >= 0.95
                                    {
                                        // Move to completed
                                        watch_state.completed.insert(media_id.clone());
                                        watch_state.in_progress.retain(|i| i.media_id != media_id);
                                        log::debug!(
                                            "Media marked as completed locally: {:?}",
                                            media_id
                                        );
                                    }
                                } else if duration > 0.0 {
                                    // Add new progress item
                                    watch_state.in_progress.push(
                                        ferrex_core::watch_status::InProgressItem {
                                            media_id: media_id.clone(),
                                            position,
                                            duration,
                                            last_watched: chrono::Utc::now().timestamp(),
                                        },
                                    );
                                    log::debug!(
                                        "Media added to in-progress locally: {:?}",
                                        media_id
                                    );
                                }
                            }

                            log::debug!(
                                "Sending periodic watch progress: position={:.1}s, duration={:?}",
                                position,
                                duration
                            );

                            return Task::perform(
                                async move {
                                    let request =
                                        ferrex_core::watch_status::UpdateProgressRequest {
                                            media_id,
                                            position,
                                            duration,
                                        };
                                    match api_client.update_watch_progress(&request).await {
                                        Ok(_) => log::debug!(
                                            "Watch progress updated: position={:.1}s",
                                            position
                                        ),
                                        Err(e) => {
                                            log::error!("Failed to update watch progress: {}", e)
                                        }
                                    }
                                },
                                |_| Message::NoOp,
                            );
                        }
                    }
                }
            }

            Task::none()
        }

        Message::VideoLoaded(success) => {
            if success {
                log::info!("Video loaded successfully - using_hls: {}, duration: {}, source_duration: {:?}",
                    state.player.using_hls, state.player.duration, state.player.source_duration);

                // Send initial watch progress update
                let mut tasks = Vec::new();

                if let (Some(api_client), Some(media)) =
                    (&state.api_client, &state.player.current_media)
                {
                    let api_client = api_client.clone();
                    // Use the stored MediaId from when PlayMediaWithId was called
                    let media_id = match state.player.current_media_id.clone() {
                        Some(id) => id,
                        None => {
                            log::error!("No MediaId stored for initial progress update");
                            return Task::none();
                        }
                    };

                    // Send initial progress (0 seconds)
                    state.player.last_progress_update = Some(std::time::Instant::now());
                    state.player.last_progress_sent = 0.0;

                    // Add to local watch state as in-progress
                    if let Some(ref mut watch_state) = state.user_watch_state {
                        // Remove from completed if it was there
                        watch_state.completed.remove(&media_id);

                        // Add to in-progress if not already there
                        if !watch_state
                            .in_progress
                            .iter()
                            .any(|item| item.media_id == media_id)
                        {
                            watch_state.in_progress.push(
                                ferrex_core::watch_status::InProgressItem {
                                    media_id: media_id.clone(),
                                    position: 0.0,
                                    duration: 0.0, // Will be updated when known
                                    last_watched: chrono::Utc::now().timestamp(),
                                },
                            );
                            log::debug!(
                                "Media added to in-progress locally on start: {:?}",
                                media_id
                            );
                        }
                    }

                    let media_id_for_log = media_id.clone();
                    tasks.push(Task::perform(
                        async move {
                            // Send initial progress update to mark as started
                            let request = ferrex_core::watch_status::UpdateProgressRequest {
                                media_id,
                                position: 0.0,
                                duration: 0.0, // Will be updated later
                            };
                            match api_client.update_watch_progress(&request).await {
                                Ok(_) => log::debug!(
                                    "Initial watch progress sent for media: {:?}",
                                    media_id_for_log
                                ),
                                Err(e) => {
                                    log::error!("Failed to send initial watch progress: {}", e)
                                }
                            }
                        },
                        |_| Message::NoOp,
                    ));
                }

                // For HLS streams, fetch the master playlist to get available quality options
                // Note: We should NOT call load_video here as it's already been loaded
                if state.player.using_hls && state.player.video_opt.is_some() {
                    // Fetch the master playlist to populate quality options
                    if let Some(media) = &state.player.current_media {
                        if let Some(client) = &state.player.hls_client {
                            let client_clone = client.clone();
                            let media_id = media.id.clone();

                            tasks.push(Task::perform(
                                async move {
                                    match client_clone.fetch_master_playlist(&media_id).await {
                                        Ok(playlist) => {
                                            log::info!(
                                                "Master playlist fetched with {} variants",
                                                playlist.variants.len()
                                            );
                                            Some(playlist)
                                        }
                                        Err(e) => {
                                            log::error!("Failed to fetch master playlist: {}", e);
                                            None
                                        }
                                    }
                                },
                                |playlist| Message::MasterPlaylistLoaded(playlist),
                            ));
                        }
                    }
                } else if state.player.using_hls && state.player.transcoding_job_id.is_some() {
                    // Continue checking transcoding status if still needed
                    tasks.push(Task::perform(
                        async {
                            tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
                        },
                        |_| Message::CheckTranscodingStatus,
                    ));
                }

                // Return combined tasks
                if tasks.is_empty() {
                    Task::none()
                } else {
                    Task::batch(tasks)
                }
            } else {
                log::error!("Video loading failed");

                let error_msg =
                    "Failed to load video. Please check the server connection and try again."
                        .to_string();
                state.error_message = Some(error_msg.clone());
                state.view = ViewState::VideoError { message: error_msg };

                Task::none()
            }
        }

        Message::VideoCreated(result) => {
            match result {
                Ok(video_arc) => {
                    log::info!("Video object created successfully");

                    // Try to extract the video from the Arc
                    let mut video = match Arc::try_unwrap(video_arc) {
                        Ok(video) => video,
                        Err(_) => {
                            log::error!("Failed to unwrap Arc<Video> - multiple references exist");
                            state.player.is_loading_video = false;
                            state.error_message =
                                Some("Internal error: video resource is locked".to_string());
                            state.view = ViewState::VideoError {
                                message: "Internal error: video resource is locked".to_string(),
                            };
                            return Task::none();
                        }
                    };

                    // Get duration - use transcoding duration as fallback for HLS streams
                    let video_duration = video.duration().as_secs_f64();
                    log::info!(
                        "Initial video duration from GStreamer: {} seconds",
                        video_duration
                    );

                    // Validate and determine the best duration source
                    let duration = match (video_duration, state.player.transcoding_duration) {
                        // Video has valid duration - use it
                        (vd, _) if vd > 0.0 && vd.is_finite() => {
                            log::info!("Using video-reported duration: {} seconds", vd);
                            vd
                        }
                        // Video duration invalid but we have transcoding duration
                        (vd, Some(td)) if td > 0.0 && td.is_finite() => {
                            log::info!(
                                "Using transcoding duration: {} seconds (video reported {})",
                                td,
                                vd
                            );
                            td
                        }
                        // Neither source has valid duration
                        _ => {
                            log::warn!(
                                "No valid duration available (video: {}, transcoding: {:?})",
                                video_duration,
                                state.player.transcoding_duration
                            );
                            // For HLS streams, duration might become available later
                            if state.player.using_hls {
                                log::info!("HLS stream - duration may update during playback");
                            }
                            0.0
                        }
                    };

                    state.player.duration = duration;
                    if duration > 0.0 {
                        log::info!(
                            "Playback duration set to: {} seconds ({:.1} minutes)",
                            duration,
                            duration / 60.0
                        );

                        // Store source duration if not already set
                        if state.player.source_duration.is_none() {
                            state.player.source_duration = Some(duration);
                            log::info!(
                                "Source duration initialized from video/transcoding metadata"
                            );
                        }
                    }

                    // Reset seeking state
                    state.player.position = 0.0;
                    state.player.dragging = false;

                    // Start playing immediately
                    video.set_paused(false);

                    // Initialize volume and mute state
                    video.set_volume(state.player.volume);
                    video.set_muted(state.player.is_muted);

                    state.player.video_opt = Some(video);
                    state.player.is_loading_video = false; // Clear loading flag
                    state.error_message = None;

                    log::info!(
                        "Video loaded - duration: {}, source_duration: {:?}, using_hls: {}",
                        state.player.duration,
                        state.player.source_duration,
                        state.player.using_hls
                    );

                    // Query available tracks after loading
                    state.player.update_available_tracks();

                    state.player.update_controls(true);

                    // Send VideoLoaded message to trigger further processing (like fetching HLS playlists)
                    Task::done(Message::VideoLoaded(true))
                }
                Err(e) => {
                    log::error!("=== VIDEO LOADING FAILED ===");
                    log::error!("Error: {}", e);

                    // Provide more helpful error message
                    let error_msg = if e.contains("StateChange") {
                        "Failed to start video pipeline. This usually means:\n\n• The media format is not supported\n• Required GStreamer plugins are missing\n• The server is not responding correctly\n\nTry checking the server logs for more details.".to_string()
                    } else {
                        format!("Video loading error: {}", e)
                    };

                    state.player.is_loading_video = false; // Clear loading flag on error
                    state.error_message = Some(error_msg.clone());
                    state.view = ViewState::VideoError { message: error_msg };

                    Task::none()
                }
            }
        }

        Message::TranscodingStarted(result) => handle_transcoding_started(state, result),

        Message::CheckTranscodingStatus => handle_check_transcoding_status(state),

        Message::TranscodingStatusUpdate(result) => handle_transcoding_status_update(state, result),

        Message::StartSegmentPrefetch(_segment_index) => {
            // TODO: Implement segment prefetching when needed
            // For now, GStreamer handles buffering internally
            Task::none()
        }

        Message::SegmentPrefetched(_index, _result) => {
            // TODO: Handle prefetched segment data
            Task::none()
        }

        Message::QualityVariantSelected(profile) => {
            // Close the quality menu
            state.player.show_quality_menu = false;

            if let Some(ref _hls_client) = state.player.hls_client {
                if let Some(ref master_playlist) = state.player.master_playlist {
                    // Empty string means "Auto" mode
                    if profile.is_empty() {
                        state.player.current_quality_profile = None;
                        log::info!("Switched to automatic quality selection");
                    } else {
                        // Find the selected variant
                        if let Some(variant) = master_playlist
                            .variants
                            .iter()
                            .find(|v| v.profile == profile)
                        {
                            state.player.current_quality_profile = Some(profile.clone());
                            log::info!(
                                "Selected quality profile: {} ({}p, {:.1} Mbps)",
                                profile,
                                variant.resolution.map(|(_, h)| h).unwrap_or(0),
                                variant.bandwidth as f64 / 1_000_000.0
                            );

                            // TODO: Implement actual variant switching in the HLS client
                            // For now, we just update the UI state
                            // In a full implementation, this would:
                            // 1. Stop fetching current variant segments
                            // 2. Switch to the new variant playlist
                            // 3. Calculate the appropriate segment to continue from
                            // 4. Start fetching from the new variant
                        }
                    }

                    // Update quality switch count for metrics
                    state.player.quality_switch_count += 1;
                }
            }

            Task::none()
        }

        Message::BandwidthMeasured(bandwidth) => {
            log::debug!("Bandwidth measured: {} bps", bandwidth);
            state.player.last_bandwidth_measurement = Some(bandwidth);

            // Check if we should switch quality based on bandwidth
            // TODO: Fix type inference issue and implement automatic quality switching
            /*
            if let Some(ref mut hls_client) = state.player.hls_client {
                if let Some(ref master_playlist) = state.player.master_playlist {
                    if let Some(new_variant) = hls_client.should_switch_variant(master_playlist) {
                        log::info!("Switching to quality variant: {}", new_variant.profile);
                        // TODO: Implement automatic quality switching
                    }
                }
            }
            */

            Task::none()
        }

        Message::ImageLoaded(cache_key, result) => {
            match result {
                Ok(_bytes) => {
                    log::info!("Image loaded for key {}", cache_key);
                    //let _handle = iced::widget::image::Handle::from_bytes(bytes);
                    // Image caching handled by UnifiedImageService
                }
                Err(e) => {
                    log::warn!("Failed to load image for {}: {}", cache_key, e);
                    // Image caching handled by UnifiedImageService
                }
            }
            Task::none()
        }

        Message::UnifiedImageLoaded(request, handle) => {
            crate::updates::unified_image::handle_unified_image_loaded(state, request, handle)
        }

        Message::UnifiedImageLoadFailed(request, error) => {
            crate::updates::unified_image::handle_unified_image_load_failed(state, request, error)
        }

        Message::UpdateBackdropHandle(handle) => {
            // Update the backdrop handle in the current view state
            match &mut state.view {
                ViewState::MovieDetail {
                    backdrop_handle, ..
                } => {
                    *backdrop_handle = Some(handle.clone());
                    log::info!("Updated movie detail backdrop handle");
                }
                ViewState::TvShowDetail {
                    backdrop_handle, ..
                } => {
                    *backdrop_handle = Some(handle.clone());
                    log::info!("Updated TV show detail backdrop handle");
                }
                ViewState::SeasonDetail {
                    backdrop_handle, ..
                } => {
                    *backdrop_handle = Some(handle.clone());
                    log::info!("Updated season detail backdrop handle");
                }
                ViewState::EpisodeDetail {
                    backdrop_handle, ..
                } => {
                    *backdrop_handle = Some(handle.clone());
                    log::info!("Updated episode detail backdrop handle");
                }
                _ => {
                    log::warn!("Received UpdateBackdropHandle for non-detail view");
                    return Task::none();
                }
            }

            // Update background shader state with the new backdrop
            state.background_shader_state.backdrop_handle = Some(handle.clone());
            // Set the display aspect ratio (21:9) for consistent layout calculations
            state.background_shader_state.backdrop_aspect_ratio =
                Some(crate::constants::layout::backdrop::DISPLAY_ASPECT);
            // Keep gradient effect active, backdrop will be overlaid in shader
            log::info!("Updated background shader state with new backdrop");

            Task::none()
        }

        Message::RefreshShowMetadata(series_id) => {
            log::info!("Refreshing metadata for show: {}", series_id.as_str());
            // TODO: Legacy metadata refresh - needs migration to new metadata domain
            Task::none()
        }

        Message::RefreshSeasonMetadata(season_id, _season) => {
            log::info!("Refreshing metadata for season: {}", season_id.as_str());
            // TODO: Legacy metadata refresh - needs migration to new metadata domain
            Task::none()
        }

        Message::RefreshEpisodeMetadata(episode_id) => {
            log::info!("Refreshing metadata for episode: {}", episode_id.as_str());
            // TODO: Legacy metadata refresh - needs migration to new metadata domain
            Task::none()
        }

        Message::CarouselNavigation(carousel_msg) => {
            match carousel_msg {
                CarouselMessage::Previous(section_id) => {
                    if section_id == "movies" {
                        // NEW ARCHITECTURE: Get carousel from ViewModel, update it, and set it back
                        let mut carousel = state.all_view_model.movies_carousel().clone();
                        carousel.go_left();
                        let scrollable_id = carousel.scrollable_id.clone();
                        let scroll_offset = carousel.get_scroll_offset();
                        state.all_view_model.update_movies_carousel(carousel);
                        // Scroll programmatically
                        return scrollable::scroll_to(scrollable_id, scroll_offset);
                    } else if section_id == "tv_shows" {
                        // NEW ARCHITECTURE: Get carousel from ViewModel, update it, and set it back
                        let mut carousel = state.all_view_model.tv_carousel().clone();
                        carousel.go_left();
                        let scrollable_id = carousel.scrollable_id.clone();
                        let scroll_offset = carousel.get_scroll_offset();
                        state.all_view_model.update_tv_carousel(carousel);
                        return scrollable::scroll_to(scrollable_id, scroll_offset);
                    } else if section_id == "show_seasons" {
                        if let Some(carousel) = &mut state.show_seasons_carousel {
                            carousel.go_left();
                            return scrollable::scroll_to(
                                carousel.scrollable_id.clone(),
                                carousel.get_scroll_offset(),
                            );
                        }
                    } else if section_id == "season_episodes" {
                        if let Some(carousel) = &mut state.season_episodes_carousel {
                            carousel.go_left();
                            return scrollable::scroll_to(
                                carousel.scrollable_id.clone(),
                                carousel.get_scroll_offset(),
                            );
                        }
                    }
                }
                CarouselMessage::Next(section_id) => {
                    if section_id == "movies" {
                        // NEW ARCHITECTURE: Get carousel from ViewModel, update it, and set it back
                        let mut carousel = state.all_view_model.movies_carousel().clone();
                        carousel.go_right();
                        let scrollable_id = carousel.scrollable_id.clone();
                        let scroll_offset = carousel.get_scroll_offset();
                        state.all_view_model.update_movies_carousel(carousel);
                        return scrollable::scroll_to(scrollable_id, scroll_offset);
                    } else if section_id == "tv_shows" {
                        // NEW ARCHITECTURE: Get carousel from ViewModel, update it, and set it back
                        let mut carousel = state.all_view_model.tv_carousel().clone();
                        carousel.go_right();
                        let scrollable_id = carousel.scrollable_id.clone();
                        let scroll_offset = carousel.get_scroll_offset();
                        state.all_view_model.update_tv_carousel(carousel);
                        return scrollable::scroll_to(scrollable_id, scroll_offset);
                    } else if section_id == "show_seasons" {
                        if let Some(carousel) = &mut state.show_seasons_carousel {
                            carousel.go_right();
                            return scrollable::scroll_to(
                                carousel.scrollable_id.clone(),
                                carousel.get_scroll_offset(),
                            );
                        }
                    } else if section_id == "season_episodes" {
                        if let Some(carousel) = &mut state.season_episodes_carousel {
                            carousel.go_right();
                            return scrollable::scroll_to(
                                carousel.scrollable_id.clone(),
                                carousel.get_scroll_offset(),
                            );
                        }
                    }
                }
                CarouselMessage::Scrolled(section_id, viewport) => {
                    // Update scroll position and max scroll based on viewport
                    if section_id == "movies" {
                        // NEW ARCHITECTURE: Get carousel from ViewModel, update it, and set it back
                        let mut carousel = state.all_view_model.movies_carousel().clone();
                        carousel.scroll_position = viewport.absolute_offset().x;
                        let content_width = viewport.content_bounds().width;
                        let viewport_width = viewport.bounds().width;
                        carousel.max_scroll = (content_width - viewport_width).max(0.0);
                        state.all_view_model.update_movies_carousel(carousel);
                    } else if section_id == "tv_shows" {
                        // NEW ARCHITECTURE: Get carousel from ViewModel, update it, and set it back
                        let mut carousel = state.all_view_model.tv_carousel().clone();
                        carousel.scroll_position = viewport.absolute_offset().x;
                        let content_width = viewport.content_bounds().width;
                        let viewport_width = viewport.bounds().width;
                        carousel.max_scroll = (content_width - viewport_width).max(0.0);
                        state.all_view_model.update_tv_carousel(carousel);
                    } else if section_id == "show_seasons" {
                        if let Some(carousel) = &mut state.show_seasons_carousel {
                            carousel.scroll_position = viewport.absolute_offset().x;
                            let content_width = viewport.content_bounds().width;
                            let viewport_width = viewport.bounds().width;
                            carousel.max_scroll = (content_width - viewport_width).max(0.0);
                        }
                    } else if section_id == "season_episodes" {
                        if let Some(carousel) = &mut state.season_episodes_carousel {
                            carousel.scroll_position = viewport.absolute_offset().x;
                            let content_width = viewport.content_bounds().width;
                            let viewport_width = viewport.bounds().width;
                            carousel.max_scroll = (content_width - viewport_width).max(0.0);
                            // Update visible range based on scroll for virtualization
                            carousel.update_visible_range_from_scroll();
                        }
                    }
                }
            }
            Task::none()
        }

        Message::WindowResized(size) => handle_window_resized(state, size),

        Message::SeekBarMoved(point) => {
            // Calculate seek position based on window width
            // Assume seek bar spans full window width
            let percentage = (point.x / state.window_size.width).clamp(0.0, 1.0) as f64;

            // Use source duration if available (for HLS this is the full media duration)
            let duration = state
                .player
                .source_duration
                .unwrap_or(state.player.duration);
            let seek_position = percentage * duration;

            // Always store the position for potential clicks
            state.player.last_seek_position = Some(seek_position);

            // If dragging, throttle seeks to prevent overwhelming the network
            if state.player.dragging {
                // Update visual position immediately for responsive UI
                state.player.position = seek_position;
                state.player.update_controls(true);

                // Check if we should perform actual seek (throttle to ~100ms intervals)
                let should_seek = match state.player.last_seek_time {
                    Some(last_time) => last_time.elapsed() > Duration::from_millis(100),
                    None => true,
                };

                if should_seek {
                    // Perform the actual seek
                    if let Some(video) = state.player.video_opt.as_mut() {
                        let duration =
                            Duration::try_from_secs_f64(seek_position).unwrap_or_default();
                        if let Err(e) = video.seek(duration, false) {
                            log::error!("Seek failed: {:?}", e);
                        } else {
                            state.player.last_seek_time = Some(Instant::now());
                            // Clear pending seek since we just performed it
                            state.player.pending_seek_position = None;
                        }
                    }
                } else {
                    // Store pending seek position to be executed later
                    state.player.pending_seek_position = Some(seek_position);
                }
            }

            Task::none()
        }

        // Handle all player messages
        msg if PlayerMessage::is_player_message(&msg) => {
            // Special handling for SeekBarMoved - calculate position using window width
            if let Some(player_msg) = PlayerMessage::from_main_message(msg) {
                state.player.update(player_msg)
            } else {
                Task::none()
            }
        }

        Message::CheckScrollStopped => {
            // Check if scrolling has actually stopped
            if let Some(last_time) = state.last_scroll_time {
                let elapsed = Instant::now().duration_since(last_time);
                if elapsed >= Duration::from_millis(SCROLL_STOP_DEBOUNCE_MS) {
                    // Scrolling has stopped
                    if state.scroll_velocity > 0.0 {
                        log::info!(
                            "Scrolling stopped (was at {:.0} px/s)",
                            state.scroll_velocity
                        );
                        state.scroll_velocity = 0.0;
                        state.fast_scrolling = false;
                        state.scroll_stopped_time = Some(Instant::now());

                        // Clear scroll samples
                        state.scroll_samples.clear();

                        let mut tasks = Vec::new();

                        // Get posters to load for visible references
                        let posters_to_load = state.get_posters_to_load_for_references();
                        log::info!(
                            "CheckScrollStopped: Found {} posters to load from references",
                            posters_to_load.len()
                        );

                        // Queue visible items for detail fetching
                        // Images are loaded on-demand through UnifiedImageService
                        // No longer queue for details - BatchMetadataFetcher handles all items

                        if tasks.is_empty() {
                            return Task::none();
                        } else {
                            return Task::batch(tasks);
                        }
                    }
                }
            }
            Task::none()
        }

        Message::NoOp => {
            // No operation needed
            Task::none()
        }

        Message::ClearError => {
            state.error_message = None;
            Task::none()
        }

        Message::MediaHovered(media_id) => {
            state.hovered_media_id = Some(media_id);
            Task::none()
        }

        Message::MediaUnhovered(media_id) => {
            // Only clear hover state if it matches the media being unhovered
            // This prevents race conditions when quickly moving between posters
            if state.hovered_media_id.as_ref() == Some(&media_id) {
                state.hovered_media_id = None;
            }
            Task::none()
        }

        Message::ToggleQualityMenu => {
            state.player.show_quality_menu = !state.player.show_quality_menu;
            // Close other menus if opening quality menu
            if state.player.show_quality_menu {
                state.player.show_settings = false;
                state.player.show_subtitle_menu = false;
            }
            Task::none()
        }

        Message::MasterPlaylistLoaded(playlist_opt) => {
            if let Some(playlist) = playlist_opt {
                log::info!(
                    "Master playlist loaded with {} quality variants",
                    playlist.variants.len()
                );
                for variant in &playlist.variants {
                    log::info!(
                        "  - {} ({}p, {:.1} Mbps)",
                        variant.profile,
                        variant.resolution.map(|(_, h)| h).unwrap_or(0),
                        variant.bandwidth as f64 / 1_000_000.0
                    );
                }
                state.player.master_playlist = Some(playlist);
            }
            Task::none()
        }

        Message::MasterPlaylistReady(playlist_opt) => {
            if let Some(playlist) = playlist_opt {
                log::info!(
                    "Master playlist is ready - loading video with {} quality variants",
                    playlist.variants.len()
                );
                state.player.master_playlist = Some(playlist);

                // Now that we confirmed the playlist exists, load the video
                load_video(state)
            } else {
                log::error!("Master playlist check failed - retrying in 2 seconds");
                // Retry checking after a delay
                Task::perform(
                    async {
                        tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
                    },
                    |_| Message::CheckTranscodingStatus,
                )
            }
        }

        Message::ExitFullscreen => {
            // Only exit fullscreen if we're actually in fullscreen
            if state.player.is_fullscreen {
                state.player.is_fullscreen = false;
                let mode = iced::window::Mode::Windowed;
                iced::window::get_latest().and_then(move |id| iced::window::set_mode(id, mode))
            } else {
                Task::none()
            }
        }

        // New reference-based messages
        Message::LibraryMediaReferencesLoaded(result) => {
            match result {
                Ok(response) => {
                    log::info!("Loaded {} media references", response.media.len());
                    let mut tasks = state.process_media_references(response);

                    // If we're in "All" view with no current library, aggregate after loading
                    if state.current_library_id.is_none() && state.view_mode == ViewMode::All {
                        log::info!("In All view mode, triggering aggregation after library load");
                        // Add a task to aggregate all cached libraries
                        tasks.push(Task::perform(async {}, |_| Message::AggregateAllLibraries));
                    }

                    // Return batched tasks
                    if tasks.is_empty() {
                        Task::none()
                    } else {
                        Task::batch(tasks)
                    }
                }
                Err(e) => {
                    log::error!("Failed to load media references: {}", e);
                    state.error_message = Some(format!("Failed to load media: {}", e));
                    state.loading = false;
                    Task::none()
                }
            }
        }

        Message::AllLibrariesLoaded(results) => {
            log::info!(
                "All libraries loaded in parallel: {} results",
                results.len()
            );
            let mut all_tasks = Vec::new();
            let mut failed_count = 0;

            // Process each library result
            for (library_id, result) in results {
                match result {
                    Ok(response) => {
                        log::info!(
                            "Successfully loaded library {}: {} media references",
                            library_id,
                            response.media.len()
                        );
                        let tasks = state.process_media_references(response);
                        all_tasks.extend(tasks);
                    }
                    Err(e) => {
                        log::error!("Failed to load library {}: {}", library_id, e);
                        failed_count += 1;
                    }
                }
            }

            // If some libraries failed but not all, continue
            if failed_count > 0 {
                state.error_message = Some(format!("{} libraries failed to load", failed_count));
            }

            // If we're in "All" view with no current library, aggregate after loading
            if state.current_library_id.is_none() && state.view_mode == ViewMode::All {
                log::info!("In All view mode, triggering aggregation after all libraries loaded");
                all_tasks.push(Task::perform(async {}, |_| Message::AggregateAllLibraries));
            }

            // Loading is complete
            state.loading = false;

            // Return batched tasks
            if all_tasks.is_empty() {
                Task::none()
            } else {
                Task::batch(all_tasks)
            }
        }

        Message::MediaDetailsUpdated(media_ref) => {
            let posters_to_load = state.handle_media_details_update(media_ref);

            // Trigger poster loading for newly available posters
            let mut tasks: Vec<Task<Message>> =
                posters_to_load.into_iter().map(|_| Task::none()).collect();

            // No longer need to trigger next item - BatchMetadataFetcher handles all items

            Task::batch(tasks)
        }
        Message::MediaDetailsBatch(batch) => handle_media_details_batch(state, batch),

        Message::CheckDetailsFetcherQueue => {
            // This message is no longer needed with the new metadata service
            // The service sends MediaDetailsUpdated messages directly
            Task::none()
        }

        Message::SeriesSortingCompleted(sorted_series) => {
            super::media_organization::handle_series_sorting_completed(state, sorted_series)
        }

        Message::QueueVisibleDetailsForFetch => {
            log::debug!("QueueVisibleDetailsForFetch message received - deprecated, using BatchMetadataFetcher");
            // No longer needed - batch metadata fetching handles all items automatically
            Task::none()
        }

        Message::RefreshViewModels => {
            // Refresh all ViewModels that were marked as needing refresh
            log::debug!("Refreshing ViewModels after batch update");

            // TODO: Move refresh operations to background thread to avoid blocking UI
            // For now, refresh synchronously but this should be optimized
            state.all_view_model.refresh_from_store();
            state.movies_view_model.refresh_from_store();
            state.tv_view_model.refresh_from_store();

            Task::none()
        }
        Message::ToggleBackdropAspectMode => {
            // Toggle between Auto and Force21x9 modes
            state.background_shader_state.backdrop_aspect_mode =
                match state.background_shader_state.backdrop_aspect_mode {
                    crate::state::BackdropAspectMode::Auto => {
                        crate::state::BackdropAspectMode::Force21x9
                    }
                    crate::state::BackdropAspectMode::Force21x9 => {
                        crate::state::BackdropAspectMode::Auto
                    }
                };
            log::info!(
                "Toggled backdrop aspect mode to: {:?}",
                state.background_shader_state.backdrop_aspect_mode
            );

            // Update depth regions to reflect the new backdrop dimensions
            state.background_shader_state.update_depth_lines(
                &state.view,
                state.window_size.width,
                state.window_size.height,
            );

            Task::none()
        }

        // Header navigation messages
        Message::NavigateHome => {
            state.view = ViewState::Library;
            state.view_mode = ViewMode::All;
            state.current_library_id = None;

            // Refresh media to show all libraries
            handle_refresh_library(state)
        }

        Message::UpdateSearchQuery(query) => {
            super::search_updates::handle_update_search_query(state, query)
        }

        Message::ExecuteSearch => super::search_updates::handle_execute_search(state),

        Message::ToggleFullscreen => {
            state.is_fullscreen = !state.is_fullscreen;
            // TODO: Implement actual fullscreen toggle
            log::info!("Fullscreen toggled to: {}", state.is_fullscreen);
            Task::none()
        }

        Message::ShowLibraryMenu => {
            state.show_library_menu = !state.show_library_menu;
            Task::none()
        }

        Message::ShowAllLibrariesMenu => {
            state.show_library_menu = !state.show_library_menu;
            state.library_menu_target = None;
            Task::none()
        }

        Message::RefreshCurrentLibrary => handle_refresh_library(state),

        Message::ScanCurrentLibrary => {
            // TODO: Implement library-specific scanning
            log::info!("Scan current library requested");
            Task::none()
        }

        Message::ShowProfile => {
            // TODO: Implement profile view
            log::info!("Show profile requested");
            Task::none()
        }

        Message::AggregateAllLibraries => {
            super::media_organization::handle_aggregate_all_libraries(state)
        }
        Message::BatchMetadataComplete => {
            log::info!("[BatchMetadataFetcher] Complete message received - hiding loading spinner");
            state.loading = false;

            // Reset the fetcher for future use
            if let Some(fetcher) = &state.batch_metadata_fetcher {
                fetcher.reset();
            }

            Task::none()
        }

        Message::InitializeMetadataService => {
            log::debug!("InitializeMetadataService message received - deprecated, using BatchMetadataFetcher");
            // Metadata service is deprecated - BatchMetadataFetcher handles all metadata fetching
            Task::none()
        }

        // Authentication messages
        Message::CheckAuthStatus => super::auth_updates::handle_check_auth_status(state),
        Message::AuthStatusConfirmedWithPin => {
            super::auth_updates::handle_auth_status_confirmed_with_pin(state)
        }
        Message::CheckSetupStatus => super::auth_updates::handle_check_setup_status(state),
        Message::SetupStatusChecked(needs_setup) => {
            super::auth_updates::handle_setup_status_checked(state, needs_setup)
        }
        Message::LoadUsers => super::auth_updates::handle_load_users(state),
        Message::UsersLoaded(result) => super::auth_updates::handle_users_loaded(state, result),
        Message::SelectUser(user_id) => super::auth_updates::handle_select_user(state, user_id),
        Message::ShowPinEntry(user) => super::auth_updates::handle_show_pin_entry(state, user),
        Message::ShowCreateUser => super::auth_updates::handle_show_create_user(state),
        Message::BackToUserSelection => super::auth_updates::handle_back_to_user_selection(state),
        Message::PinDigitPressed(digit) => {
            super::auth_updates::handle_pin_digit_pressed(state, digit)
        }
        Message::PinBackspace => super::auth_updates::handle_pin_backspace(state),
        Message::PinClear => super::auth_updates::handle_pin_clear(state),
        Message::PinSubmit => super::auth_updates::handle_pin_submit(state),
        Message::LoginSuccess(user, permissions) => {
            super::auth_updates::handle_login_success(state, user, permissions)
        }
        Message::LoginError(error) => super::auth_updates::handle_login_error(state, error),
        Message::WatchStatusLoaded(result) => {
            super::auth_updates::handle_watch_status_loaded(state, result)
        }
        Message::Logout => super::auth_updates::handle_logout(state),
        Message::LogoutComplete => super::auth_updates::handle_logout_complete(state),

        // Password login messages
        Message::ShowPasswordLogin(username) => {
            super::auth_updates::handle_show_password_login(state, username)
        }
        Message::PasswordLoginUpdateUsername(username) => {
            super::auth_updates::handle_password_login_update_username(state, username)
        }
        Message::PasswordLoginUpdatePassword(password) => {
            super::auth_updates::handle_password_login_update_password(state, password)
        }
        Message::PasswordLoginToggleVisibility => {
            super::auth_updates::handle_password_login_toggle_visibility(state)
        }
        Message::PasswordLoginToggleRemember => {
            super::auth_updates::handle_password_login_toggle_remember(state)
        }
        Message::PasswordLoginSubmit => super::auth_updates::handle_password_login_submit(state),

        // Device authentication flow messages
        Message::AuthFlowDeviceStatusChecked(user, result) => {
            super::auth_updates::handle_device_status_checked(state, user, result)
        }
        Message::AuthFlowUpdateCredential(input) => {
            super::auth_updates::handle_auth_flow_update_credential(state, input)
        }
        Message::AuthFlowSubmitCredential => {
            super::auth_updates::handle_auth_flow_submit_credential(state)
        }
        Message::AuthFlowTogglePasswordVisibility => {
            super::auth_updates::handle_auth_flow_toggle_password_visibility(state)
        }
        Message::AuthFlowToggleRememberDevice => {
            super::auth_updates::handle_auth_flow_toggle_remember_device(state)
        }
        Message::AuthFlowAuthResult(result) => {
            super::auth_updates::handle_auth_flow_auth_result(state, result)
        }
        Message::AuthFlowSetupPin => Task::none(), // TODO: Implement
        Message::AuthFlowUpdatePin(pin) => Task::none(), // TODO: Implement
        Message::AuthFlowUpdateConfirmPin(pin) => Task::none(), // TODO: Implement
        Message::AuthFlowSubmitPin => super::auth_updates::handle_auth_flow_submit_pin(state),
        Message::AuthFlowPinSet(result) => {
            super::auth_updates::handle_auth_flow_pin_set(state, result)
        }
        Message::AuthFlowRetry => Task::none(), // TODO: Implement
        Message::AuthFlowBack => Task::none(),  // TODO: Implement

        // First-run setup messages
        Message::FirstRunUpdateUsername(username) => {
            super::first_run_updates::handle_update_username(state, username)
        }
        Message::FirstRunUpdateDisplayName(display_name) => {
            super::first_run_updates::handle_update_display_name(state, display_name)
        }
        Message::FirstRunUpdatePassword(password) => {
            super::first_run_updates::handle_update_password(state, password)
        }
        Message::FirstRunUpdateConfirmPassword(confirm_password) => {
            super::first_run_updates::handle_update_confirm_password(state, confirm_password)
        }
        Message::FirstRunTogglePasswordVisibility => {
            super::first_run_updates::handle_toggle_password_visibility(state)
        }
        Message::FirstRunSubmit => super::first_run_updates::handle_submit(state),
        Message::FirstRunSuccess => super::first_run_updates::handle_success(state),
        Message::FirstRunError(error) => super::first_run_updates::handle_error(state, error),

        _ => {
            // This should not happen as all messages should be handled above
            log::warn!("Unhandled message: {:?}", message);
            Task::none()
        }
    };

    PROFILER.end(&format!("update::{}", message_name));
    result
}
